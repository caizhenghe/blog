# C语言基础

## 基础数据类型

| 32位系统       | char | short | int  | long | float | double |
| -------------- | ---- | ----- | ---- | ---- | ----- | ------ |
| 内存大小(byte) | 1    | 2     | 4    | 4    | 4     | 8      |

指针的内存大小与系统相关，32位系统中是4字节，64位系统中是8字节。

### 类型转换

**自动转换规则**

- 混合运算时，低精度类型会自动转换成高精度类型。
- 所有的浮点运算都是以双精度进行的，即float会先转换成double再进行运算。（FIXME）
- char和short参与运算时，会先转换成int。
- 有符号整型和无符号整型运算时，有符号整型会自动转换成无符号整型。

## 大小端

- 大端模式：数据的高字节保存在内存的低地址，符合阅读习惯。
- 小端模式：数据的高字节保存在内存的高地址。

使用 **unsigned char buf[4]** 来描述数据**0x12345678**的内存地址：

|          | 大端模式                                                   | 小端模式                                                   |
| -------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| 内存地址 | buf[0] = 0x12，buf[1] = 0x34，buf[2] = 0x56，buf[3] = 0x78 | buf[0] = 0x78，buf[1] = 0x56，buf[2] = 0x34，buf[3] = 0x12 |

## 运算符

**自增运算**

- 左自增运算：先将自身加1，再代入到其他表达式中。
- 右自增运算：先代入到其他表达式中，再将自身加1。

**或运算**

符合一个条件后就不会执行后续判断。

## 打印格式

%#X：十六进制，大写字母，结果前面加0X

## strncpy

```c
// 函数原型
char *strncpy(char *dest,char *src,int size_t n); 
```

- 如果n小于src的长度，将src的前n个字符复制到dest的前n个字符，**不自动添加'\0'**。
- 如果n大于src的长度，则以NULL填充dest直至n个字符。
- dest和src所指内存区域不能重叠且dest必须有足够的空间容纳src的字符长度+'\0'

## snprintf

```c
// 函数原型
int snprintf(char *str, size_t size, const char *format, ...)。
```

- 若**格式化后的字符串**长度小于size，将此字符串全部赋给str，并且在其后添加'\0'。
- 若格式化后的字符串长度大于等于size，则只将其中的size-1个字符赋给str，并添加一个'\0'，返回值为欲写入字符串的长度。

## sscanf

读取格式化的字符串中的数据。