- # Java容器

  | tag  | author     | date       | history    |
  | ---- | ---------- | ---------- | ---------- |
  | Java | caizhenghe | 2018-03-11 | create doc |

  [Java容器]()[HashMap]()[特点]()[LikedHashMap]()[特点]()[TreeMap]()[特点]()[使用场景]()

  ## HashMap

  ### 特点

  无序，散列表，数组+链表/红黑树

  1. 通过hashcode取余的方式查找数组的索引bucketIndex
  2. 通过遍历链表找到对应的位置

  ## LikedHashMap

  ### 特点

  有序，以插入顺序或者访问顺序排序，在HashMap的基础上增加了一个双向链表来记录顺序

  ## TreeMap

  ### 特点

  有序，以Key的大小排序

  ### 使用场景

  判断某个有序序列是否与另一个有序序列相交(LeetCode 729)

  - floorKey(int start): 返回不大于start的最大键值对的Key，没有则返回null
  - ceilingKey(int start):返回不小于start的最小键值对的Key，没有则返回null

  ```
  Integer floorKey = mMap.floorKey(start);
  if(floorKey != null && mMap.get(floorKey) > start) return false; // 相交
  Integer ceilingKey = mMap.ceilingKey(start);
  if(ceilingKey != null && ceilingKey < end) return false; // 相交
  ```

  > Tips: 
  >
  > 不借助TreeMap判断某个有序序列是否与另一个有序序列相交：
  >
  > ```
  > Math.max(b[0], start) < Math.min(b[1], end) // 相交
  > ```
  >
  > 判断是否三重相交的方法（有三重相交的序列不进行存储）：
  >
  > 每次相交之后将相交部分存储到另一个List中，并判断相交部分是否与该List之前存储的序列相交
  >
  > 不论几次相交均进行存储，计算有序序列（包括之前已存储的序列）的相交次数：
  >
  > ```
  >     private TreeMap<Integer, Integer> map = new TreeMap<>();
  >     public int book(int s, int e) {
  >         timeline.put(s, map.getOrDefault(s, 0) + 1); // 1 new event will be starting at [s]
  >         timeline.put(e, map.getOrDefault(e, 0) - 1); // 1 new event will be ending at [e];
  >         int ongoing = 0, k = 0;
  >         for (int v : map.values())
  >             k = Math.max(k, ongoing += v);
  >         return k;
  >     }
  > ```