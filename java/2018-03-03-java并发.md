#  Java并发

| tag  | author     | date       | history                                        |
| ---- | ---------- | ---------- | ---------------------------------------------- |
| Java | caizhenghe | 2018-03-03 | create doc                                     |
| java | caizhenghe | 2018-07-31 | Update thread content                          |
| java | caizhenghe | 2018-08-01 | Add Join/Interrupt and Catch exception chapter |
| java | caizhenghe | 2018-08-02 | Add Mutex Chapter                              |
| java | caizhenghe | 2018-08-05 | Add Atomic Chapter                             |
| java | caizhenghe | 2018-08-06 | Interrupt thread in block state                |
| java | caizhenghe | 2018-08-07 | Check interrupt state                          |
| java | caizhenghe | 2018-08-12 | Add synchronized chapter                       |

[TOC]

## 线程的状态

### 五种状态

线程有五种状态：新建状态、可运行状态（就绪状态）、运行状态、阻塞状态、死亡状态。

- 新建状态：使用new创建一个线程时，在start()之前，线程处于新建状态。
- 就绪状态：调用了start()方法，但未真正获取CPU时间之前，线程处于就绪状态。还有些情况会进入就绪状态：
  - 运行状态的线程调用了**yield()**方法后，有可能回到就绪状态（CPU重新选择一个就绪线程执行，这个线程有可能依然是它）。
  - 被挂起的线程调用**notify()**方法回到就绪状态。
  - 睡眠的线程达到时限后回到就绪状态。
- 运行状态：线程真正获取CPU时间之后，即处于运行状态，开始执行任务的run()方法。
- 阻塞状态：进入阻塞状态的情况有很多：
  - 调用**sleep()**进入睡眠状态
  - 调用**wait()**将线程挂起
  - 调用一个在I/O被阻塞的操作
  - 试图得到一个锁且该锁被其它线程持有
- 死亡状态：当run()方法执行完毕后，线程进入死亡态，此时线程对象不一定会被gc（可能还有强引用持有该对象）。可以通过isAlive()方法判断线程的状态（true表示就绪状态/运行/阻塞状态，false表示新建/死亡状态）。

> Tips:线程会注册自己，在任务执行过程中，线程对象不会被gc

### Sleep和Wait的区别

- Sleep属于Thread的方法，Wait属于Object的方法
- Sleep不会释放锁，当某个持有锁的线程睡眠时，其他线程依旧无法获得这个锁；Wait会释放锁，当某个持有锁的线程挂起时，其他线程可以获得这个锁。

## 线程池

// TODO

## 异步任务的返回值

通过Callable取代Runnable来产生返回值（线程池也可以submit一runnable并返回Future<?>对象，**该对象不包含返回值但可以用于中断线程**）。

```java
ExecutorService exec = Executors.newCachedThreadPool();
Future<String> result = exec.submit(new Callable<String>() {
    @Override
    public String call() {
        return null;
    }
});

// block until completion
result.get();

// check if complete
result.isDone();
```



## 线程优先级

线程调度器会优先选择优先级高的线程。

设置方式：Thread的**setPriority()**方法，设置的时机是在**run()方法的起始位置**。

JDK制定的优先级与操作系统的映射不是很好，通常只使用三种优先级：MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY。

## 后台线程

当所有非后台线程结束时，程序就终止了，同时会杀死所有 后台线程（立即停止，无法确保后台线程中的finally代码块能够执行完毕）。

设置方式：Thread的**setDaemon()**方法。可以通过**isDaemon()**方法来判断一个线程是否是后台线程。

## 线程插队

### Join和Interrupt

- 线程A可以在线程B中调用**A.join()**方法，此时线程B被挂起，直到线程A结束才恢复。该方法可以捕获**InterruptedException**异常。
- 可以在另一个线程中调用**A.interrupt()**方法，打断线程A，提前恢复线程B。

### CyclicBarrier

// TODO

## 捕获异常

正常情况下，一旦异常逃出任务的run()方法，它就会向外传播到控制台，因此我们不能在run()方法之外捕获异常。

但是我们可以自定义一个ThreadFactory，用于创建某种特定的Thread，我们通过**setUncaughtExceptionHandler()**方法给Thread设置了未捕获异常的监听器，当线程因为异常而即将退出时，会执行该Handler。

```java
ExecutorService exec = Executors.newCachedThreadPool(new ThreadFactory() {
    @Override
    public Thread newThread(@NonNull Runnable r) {
        Thread t = new Thread(r);
        t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                // TODO
            }
        });
        return t;
    }
});
```

当所有的线程在捕获异常时均执行同一操作时，可以使用Thread的静态方法**setDefaultUncaughtExceptionHandler()**设置Handler。

```java
Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        // TODO
    }
});
```

> Tips：前者的优先级比后者高。

## 多线程的特性

### 原子性

概念：原子性操作一定能在切换到其它线程执行之前执行完毕。

对**除了double和long的基本数据类型**进行简单的读取和赋值操作被认为是安全的原子性操作。JVM会将64位数据（double和long）的读取和写入当作两个分离的32位操作来执行（**volatile关键字可以让long和double也获得原子性**）。

在java中，**递增不是原子性操作**。通过JVM指令可以看到，递增操作会产生get和put，它们之间还有一些其它指令，是有可能被其它任务打断的。

> Notice：在非Volatile域上的原子操作不必刷新到主存中，其它读取该域的任务也不必看到新值，还是会发生线程问题，所以**原子操作必须和volatile结合使用**。

**原子类**

AtomicInteger、AtomicLong、AtomicRefrence等类提供了一系列机器级别的原子性方法，性能比同步操纵要更好。

```java
private AtomicInteger i = new AtomicInteger(0);
i.get(); // 获取值
i.AddAndGet(2); // 自增2
```



### 可见性

概念：对一个域作出的修改能立即被其它任务看到。

**volatile**

volatile可以保证线程的可见性（Java SE5之后，这个关键字才生效）。如果用volatile修饰一个域，对这个域进行写操作，所有的读操作都能看到这个修改（volatile域会被立即写到主存中，而读操作就发生在主存中）。**但是volatile不能保证原子操作**。

当一个域的值依赖于它之前的状态（递增）或者其它域的值，volatile是无效的（FIXME：此处描述的应该是无法保证原子性）。唯一安全的情况是**类中只有一个可变的域**。

volatile关键字会告诉编译器**不要执行移除读写操作的优化**（这些优化的目的是用线程中的局部变量维护对这个域的精确同步）。// FIXME：这个概念是否与可见性原则相违背？

## 互斥

### synchronized

1. 修饰方法：本质上是锁住了类的this对象，当一个线程调用了某个对象中的synchronized方法时，**这个对象的所有synchronized方法**都不能被其它线程调用。如果修饰的静态方法，这个类的**所有对象中的所有synchronized方法**在同一时间都只能被一个线程独占。

   ```java
   public synchronized void get(int i, String name){}
   ```
   - 将域设置为private很有必要，否则synchronized关键字无法防止其它任务直接访问域。


   - 一个任务可以**多次获得对象的锁**（比如在一个synchronized方法中调用同个对象的另一个synchronized方法），JVM会对其计数，当该对象被最终释放，即计数为0时，其它任务才可以获得该对象的锁。

2. 修饰代码块：跟修饰方法类似，新建一个对象，在要求互斥的代码块上锁住这个对象，在同一时间就只有一个线程访问该代码块了。这个新建对象不一定是Object类型，任意类型都可以，在一些对内存要比较抠门的项目中，可以新建一个byte[]类型的对象。

   ```java
   public void get(int i, String name) {
           synchronized (obj) {
               // do something
           }
   }
   ```

### Lock

优点：

- 当使用synchronized关键字时，若抛出异常，没有机会去做清理工作；而Lock可以在finally子句中进行清理工作。
- 当程序有线程公平性需要时，可以使用这种载入式的加锁方式。（可以解决一些复杂的场景，比如尝试获取锁且最终获取失败；尝试获取一段时间锁然后放弃它）

缺点：相较于synchronized，Lock需要更大的开销，代码量更大，更容易引起错误。

// TODO 了解ReentranLock使用的具体场景

```java
private Lock mLock = new ReentrantLock(); 
public int method() {
    mLock.lock();
    // 尝试获取锁
    // boolean captured = mLock.tryLock();
    // boolean captured = mLock.tryLock(2, TimeUnit.SECONDS);
    try {
        // do something
        // return必须放在try子句中，以确保unlock()不会过早发生，从而将数据暴露给其它任务
        return 0;
    } finally {
        // if(captured)
        // 无论有无interrupt发生，均会执行finally代码块，通常用于清理资源
        mLock.unlock();
    }
}
```

## ThreadLocal

在不同的线程中存储不同的数据副本。ThreadLocal对象通常当作静态域存储，使用它时不需要加锁。

```java
private static ThreadLocal<Integer> sThreadLocal = new ThreadLocal<Integer>(){
    private Random random = new Random(47);
    @Override
    protected synchronized Integer initialValue() {
        // FIXME：initialValue方法是否有必要添加synchronized关键字？
        // 重写初始化默认值的方法
        return random.nextInt(1000);
    }
};

sThreadLocal.get();  // 获取当前线程对应的数据副本
```

## 终止任务

### 线程池的终结方式

#### shutdown和shutdownNow

shutdown()方法允许正在执行的任务执行完毕，但是不允许线程池执行新任务；shutdownNow()方法要求所有任务（包括正在执行的任务）立即停止。

#### awaitTerminate

等待所有任务结束，若所有任务在超时时间之前结束，则返回true，不然返回false。

### 在阻塞时终结

- 使用cancel变量可以使程序在运行状态被终结，但是不能使任务在阻塞状态被终结。此时可以使用之前提到过的Thread的**interrupt()**方法，通过这个方法可以在任务中抛出一个InterruptExeption异常。
- 如果我们想通过Executor来打断任务，可以使用**shutdownNow()**方法，该方法会对线程池中所有线程执行interrupt()。
- 如果想通过Executor打断某个单一的线程。可以使用submit提交一个任务，该方法会返回一个Future对象，可以执行该对象的**cancel(true)**方法来打断线程。

> Notice：sleep()阻塞是可以被终结的，但I/O和synchronized块上的阻塞是无法被终结的。不过我们可以通过**关闭底层资源**（例如InputStream）的方式来终结I/O阻塞的任务。

#### lock和lockInterruptibly

上述几种方式无法中断synchronized块互斥造成的阻塞，**但是可以中断ReentranLock的lockInterruptibly()方法引起的互斥阻塞**。

- lock：优先考虑获取锁，待获取锁成功后，才响应中断。
- lockInterruptibly：优先考虑响应中断，而不是响应锁的普通获取或重入获取。

#### 检查中断状态

纠正一点上面的说法，Thread的interrupt()方法不能真正打断某个任务，只是将该任务置为打断状态。需要我们手动去捕获异常并终结该任务。若不想捕获异常，我们可以使用Thread的**interrupted()**方法检查中断状态并终结任务。检查中断状态有两种方式，分别是静态方法interrupted()和非静态方法isInterrupted()。

- interrupted：检查当前线程的打断状态，并且会重置打断标识位。
- isInterrupted：检查调用该方法的线程对象的打断状态，并且不会重置打断标识位。

## 同步

### wait和notify

通过wait()方法将任务挂起并释放锁，此时其它任务可以获取锁并调用synchronized修饰的方法。通过notify()/notifyAll()方法或者**等待指定的时间**可以唤醒挂起的任务。

**wait通常使用while检查而不是if**，避免线程机制自身的不稳定导致异常。

> Notice：wait()、notify()、notifyAll()方法必须在**同步控制块**中执行，不然会报IllegalMonitorStateException。

### 信号错失

为了防止信号错失导致wait的任务没有被notify唤醒而一直死锁，要将对于条件的判断放在synchronized代码块中。例子如下：

```java
T1:
synchronized(object){
    isWait = false;
    object.notify();
}

T2: 错误范例
while(isWait) {
	synchronized(object) {
		object.wait();
	}
}

T2: 正确范例
synchronized(object) {
	while(isWait) {
		object.wait();
	}
}
```

### notify和notifyAll

- notifyAll可以唤醒对应锁的所有任务，更加安全。
- notify是notifyAll的一种优化，notify只会唤醒**一个**等待对应锁的任务。