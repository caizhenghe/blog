# Java并发

| tag  | author     | date       | history                                        |
| ---- | ---------- | ---------- | ---------------------------------------------- |
| Java | caizhenghe | 2018-03-03 | create doc                                     |
| java | caizhenghe | 2018-07-31 | Update thread content                          |
| java | caizhenghe | 2018-08-01 | Add Join/Interrupt and Catch exception chapter |

[TOC]

## 线程的状态

### 五种状态

线程有五种状态：新建状态、可运行状态（就绪状态）、运行状态、阻塞状态、死亡状态。

- 新建状态：使用new创建一个线程时，在start()之前，线程处于新建状态。
- 就绪状态：调用了start()方法，但未真正获取CPU时间之前，线程处于就绪状态。还有些情况会进入就绪状态：
  - 运行状态的线程调用了**yield()**方法后，有可能回到就绪状态（CPU重新选择一个就绪线程执行，这个线程有可能依然是它）。
  - 被挂起的线程调用**notify()**方法回到就绪状态。
  - 睡眠的线程达到时限后回到就绪状态。
- 运行状态：线程真正获取CPU时间之后，即处于运行状态，开始执行任务的run()方法。
- 阻塞状态：进入阻塞状态的情况有很多：
  - 调用**sleep()**进入睡眠状态
  - 调用**wait()**将线程挂起
  - 调用一个在I/O被阻塞的操作
  - 试图得到一个锁且该锁被其它线程持有
- 死亡状态：当run()方法执行完毕后，线程进入死亡态，此时线程对象不一定会被gc（可能还有强引用持有该对象）。可以通过isAlive()方法判断线程的状态（true表示就绪状态/运行/阻塞状态，false表示新建/死亡状态）。

> Tips:线程会注册自己，在任务执行过程中，线程对象不会被gc

### Sleep和Wait的区别

- Sleep属于Thread的方法，Wait属于Object的方法
- Sleep不会释放锁，当某个持有锁的线程睡眠时，其他线程依旧无法获得这个锁；Wait会释放锁，当某个持有锁的线程挂起时，其他线程可以获得这个锁。

## 线程池

// TODO

## 异步任务的返回值

通过Callable而不是Runnable来产生返回值。

```java
ExecutorService exec = Executors.newCachedThreadPool();
Future<String> result = exec.submit(new Callable<String>() {
    @Override
    public String call() {
        return null;
    }
});

// block until completion
result.get();

// check if complete
result.isDone();
```



## 线程优先级

线程调度器会优先选择优先级高的线程。

设置方式：Thread的**setPriority()**方法，设置的时机是在**run()方法的起始位置**。

JDK制定的优先级与操作系统的映射不是很好，通常只使用三种优先级：MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY。

## 后台线程

当所有非后台线程结束时，程序就终止了，同时会杀死所有 后台线程（立即停止，无法确保后台线程中的finally代码块能够执行完毕）。

设置方式：Thread的**setDaemon()**方法。可以通过**isDaemon()**方法来判断一个线程是否是后台线程。

## 加入和中断

### Join和Interrupt

- 线程A可以在线程B中调用**A.join()**方法，此时线程B被挂起，直到线程A结束才恢复。该方法可以捕获**InterruptedException**异常。
- 可以在另一个线程中调用**A.interrupt()**方法，打断线程A，提前恢复线程B。

### CyclicBarrier

## 捕获异常

正常情况下，一旦异常逃出任务的run()方法，它就会向外传播到控制台，因此我们不能在run()方法之外捕获异常。

但是我们可以自定义一个ThreadFactory，用于创建某种特定的Thread，我们通过**setUncaughtExceptionHandler()**方法给Thread设置了未捕获异常的监听器，当线程因为异常而即将退出时，会执行该Handler。

```java
ExecutorService exec = Executors.newCachedThreadPool(new ThreadFactory() {
    @Override
    public Thread newThread(@NonNull Runnable r) {
        Thread t = new Thread(r);
        t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                // TODO
            }
        });
        return t;
    }
});
```

当所有的线程在捕获异常时均执行同一操作时，可以使用Thread的静态方法**setDefaultUncaughtExceptionHandler()**设置Handler。

```java
Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        // TODO
    }
});
```

> Tips：前者的优先级比后者高。

## synchronized

1. 修饰方法：本质上是锁住了类的this对象，当一个线程调用了某个对象中的synchronized方法时，这个对象的所有方法都不能被其它线程调用。如果修饰的静态方法，这个类的所有对象中的所有方法在同一时间都只能被一个线程独占。

   ```java
   public synchronized void get(int i, String name){}
   ```

2. 修饰代码块：跟修饰方法类似，新建一个对象，在要求互斥的代码块上锁住这个对象，在同一时间就只有一个线程访问该代码块了。这个新建对象不一定是Object类型，任意类型都可以，在一些对内存要比较抠门的项目中，可以新建一个byte[]类型的对象。

   ```java
   public void get(int i, String name) {
           synchronized (obj) {
               // todo
           }
   }
   ```

## volatile

> 用volatile修饰变量的一个最大特性就是使变量具有线程可见性，当一个线程中修改了volatile变量时，其他线程能够马上得到该变量的最新对象。但是volatile不能保证原子操作。