# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          List<Integer> output = new ArrayList<Integer>();
          public List<Integer> inorderTraversal(TreeNode root) {
              if(root == null) {
                  return output;
              }
              inorderTraversal(root.left);
              output.add(root.val);
              inorderTraversal(root.right);
              return output;
          }
      }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```


## 2018-12-04

1. （Star）输入一个数组，输出该数组的所有序列List<List\<Integer\>>。#46

   > 基本思路：
   >
   > 1. n个数的数组有n\*(n-1)\*...\*2\*1种组合。
   > 2. 当a添加至包含n-1个数的数组时，将a与数组中的每个数替换，都会有(n-1)\*(n-1)\*…1种组合，最终形成第一点所说的组合数目。
   >
   > Tips：List的addAll和clone都是浅拷贝，每个元素都指向同一块内存地址。



   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> results = new ArrayList<List<Integer>>();
           
           permuteRecursion(results, nums, 0, nums.length - 1);
           
           return results;
       }
       
       public void permuteRecursion(List<List<Integer>> results, int[] nums, int start, int end) {
           if(start == end) {
               List<Integer> result = new ArrayList<Integer>();
               for (int num : nums) {
                   result.add(num);
               }
               results.add(result);
           } else {
               for(int i = start; i <= end; i++) {
                   nums = swap(nums, start, i);
                   permuteRecursion(results, nums, start + 1, end);
                   nums = swap(nums, start, i);
               }
           }
       }
       
       public int[] swap(int[] nums, int first, int second) {
           int c = nums[first];
           nums[first] = nums[second];
           nums[second] = c;
           
           return nums;
       }
   }
   ```

2. 输入n，输出所有可能的括号排序List\<String\>，要求左右括号一一对应。#22

   > Tips：String、StringBuffer、StringBuilder的区别：（TODO）
   >
   > 修改String的值本质上是给它分配了一块新的内存地址；StringBuffer的append方法则是在原来的内存地址上修改值。
   >
   > 基本思路：
   >
   > 1. 剩余左括号的数量小于等于剩余右括号的数量。
   > 2. 使用递归的思路，当剩余左括号为0时，append所有剩余右括号；当剩余左括号等于右括号时，append左括号并递归；其余情况分别append左括号和右括号并递归（append右括号时需要往List中添加新的字符串）。



   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<StringBuffer> tmp = new ArrayList<StringBuffer>();
           StringBuffer sb = new StringBuffer("");
           tmp.add(sb);
           recursion(tmp, sb, n, n);
   
           List<String> result = new ArrayList<String>();
           for(StringBuffer item : tmp) {
               result.add(item.toString());
           }
           return result;
       }
   
       public void recursion(List<StringBuffer> list, StringBuffer s, int left, int right) {
           if (left == 0) {
               while(right > 0) {
                   s.append(")");
                   right--;
               }
           }
           else if(left == right) {
               s.append("(");
               recursion(list, s, left - 1, right);
           } else {
               StringBuffer tmp = new StringBuffer(s.toString());
               s.append("(");
               recursion(list, s, left - 1, right);
               list.add(tmp.append(")"));
               recursion(list, tmp, left, right - 1);
           }
       }
   }
   ```


## 2018-12-05

1. 输入一个无重复元素的数组（distinct integers），输出所有的子集List<List\<Integer\>>，要求子集不能有重复。#78

   > 基本思路：找规律，假设已经得到nums[0～n-1]的子集Subset1，深拷贝一份子集Subset2，再将nums[n]加入Subset2的每个元素中即可。



   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> results = new ArrayList<>();
           results.add(new ArrayList<Integer>());
           if(nums == null || nums.length == 0)
               return results;
           int end = 0;
           while(end < nums.length) {
               int originSize = results.size();
               results.addAll(deepClone(results));
               for(int i = originSize; i < results.size(); i++) {
                   results.get(i).add(nums[end]);
               };
               end++;
           }
           return results;
       }
       
       public List<List<Integer>> deepClone(List<List<Integer>> reses) {
           List<List<Integer>> results = new ArrayList<>();
           for(List<Integer> res : reses) {
               List<Integer> result = new ArrayList<>();
               for(Integer i : res) {
                   result.add(i);
               }
               results.add(result);
           }
           return results;
       }
   }
   ```

2. 输入BST的根节点和k，返回BST中第k小的元素。#230

   > Tips：
   >
   > 1. BST（二叉搜索树）的概念：左子节点<根节点<右子节点。
   > 2. B树、B+树、B-树、B*树的概念。（TODO）
   >
   > 基本思路：
   >
   > BST中，中序遍历BST，第k个节点就是Kth smallest element。



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public int kthSmallest(TreeNode root, int k) {
           List<Integer> result = new ArrayList<Integer>();
           recursion(root, result, k);
           return result.get(k - 1);
       }
       
       public void recursion(TreeNode root, List<Integer> list, int k) {
           if(root == null || list.size() >= k)
               return;
           recursion(root.left, list, k);
           list.add(root.val);
           recursion(root.right, list, k);
       }
   }
   ```


## 2018-12-06

1. 输入两个链表，输出一个链表，要求每个元素是输入链表对应位置元素之和，包含进位。#2

   ```java
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           ListNode node = new ListNode(0);
           ListNode iterator = node;
           int add = 0;
           while (l1 != null || l2 != null || add > 0) {
               int x = 0, y = 0, all = 0;
               if (l1 != null) {
                   x = l1.val;
                   l1 = l1.next;
               }
   
               if (l2 != null) {
                   y = l2.val;
                   l2 = l2.next;
               }
   
               all = x + y + add;
               add = all / 10;
               iterator.val = all % 10;
               if (l1 != null || l2 != null || add > 0)
                   iterator.next = new ListNode(0);
               iterator = iterator.next;
           }
           return node;
       }
   }
   ```

2. （Star）输入一个字符串，输出其中不重复的连续子字符串的最大长度。#3

   > 基本思路：
   >
   > 1. 使用Map，其中key表示字符，value表示字符出现的顺序索引，记录一个不重复子串的初始索引。遍历字符串，若字符索引大于等于初始索引，说明该字符已经存在，更新最大长度和当前子串长度，更新初始索引，并对该字符记录新的索引；若该字符不存在， ，并对该字符记录索引。
   > 2. 若使用Hash数组代替Map，使用数组下标代替key，需要开辟能够包含所有ASC字符的数组（ASC表长度为177）。
   > 3. Discuss其余思路（TODO）



   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           if(s == null || s.equals(""))
               return 0;
           int[] hash = new int[178];
           int max = 0, length = 0, validIndex = 100;
           for(int i = 0; i < s.length(); i++) {
               char c = s.charAt(i);
               int index = hash[c - '\0'];
               if(index >= validIndex) {
                   max = Math.max(max, length);
                   length = length - (index - validIndex);
                   validIndex = index + 1;
               } else {
                   length++;
               }
               hash[c - '\0'] = validIndex + length - 1;
   
           }
           return Math.max(max, length);
       }
   }
   ```


## 2018-12-08

1. （Star）求有序二维矩阵中的第k小的值。#378

   > 基础知识点：
   >
   > 1. 堆排序：要求子节点比父节点大/小，根节点最大/小。每次插入元素后堆重新排序，排序后依然满足前述特点。
   > 2. PriorityQueue：有序队列，内部使用堆排序的方式排列数据，有以下特点：
   >    - 不满足FIFO（先入先出，队尾插入队首移除）。
   >    - 直接打印队列时数据是无序的，只能保证队首元素最大/最小。遍历出栈的数据是有序的。
   >    - PriorityQueue有两种排序方式：
   >      - 自然排序：按元素的大小排序，数据以升序的方式出列。
   >      - 定制排序：复写Comparator\<T\>接口，元素的compareTo方法返回负数时，堆重新排序，将该元素放到队首；返回正数时，直接将元素插到队尾，不重新排序。
   >    - poll/offer和remove/add的区别：
   >      - 当队列为空时，poll直接返回null，remove抛出异常。
   >      - 当队列为满时，offer直接返回false，而add返回uncheck异常。
   >    - peek和element的区别：两者均是搜索队首元素，但不将其出列。当队列为空时，peek返回null，element抛出异常。
   >
   >
   >
   > 基本思路：
   >
   > 1. 每个元素需要记录自身的位置（x,y），借助PriorityQueue进行排序，要求队首元素最小。
   > 2. 将二维矩阵的第一行元素入列。
   > 3. 遍历k-1次，每次遍历时出列一个元素（x,y），并将（x，y+1）元素入列（当y到达最后一行时，直接出列下一个元素）。
   > 4. 出列k-1个元素后，下个元素就是Kth smallest。



   ```java
   class Solution {
           class Tuple implements Comparable<Tuple> {
               int x;
               int y;
               int val;
   
               public Tuple(int x, int y, int val) {
                   this.x = x;
                   this.y = y;
                   this.val = val;
               }
   
   
               @Override
               public int compareTo(Tuple o) {
                   return this.val - o.val;
               }
           }
   
           public int kthSmallest(int[][] matrix, int k) {
               int n = matrix.length;
               PriorityQueue<Tuple> queue = new PriorityQueue<>();
               for (int i = 0; i < n; i++) {
                   queue.offer(new Tuple(i, 0, matrix[i][0]));
               }
   
               for (int i = 0; i < k - 1; i++) {
                   Tuple e = queue.poll();
                   if (e.y == n - 1) continue;
                   queue.offer(new Tuple(e.x, e.y + 1, matrix[e.x][e.y + 1]));
               }
               return queue.poll().val;
           }
       }
   ```

2. 将一个链表重新排序，要求奇数下标的节点相连，偶数下标的节点相连，最后将偶数节点链表接在奇数节点链表后面。要求空间复杂度为O(1)，时间复杂度为O(n)。#328

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode oddEvenList(ListNode head) {
           if(head == null)
               return null;
           
           ListNode evenHead = head.next;
           ListNode lastOddCache = null;
           ListNode it = head;
           int nodeCount = 1;
           while(it.next != null) {
               ListNode tmp = it.next;
               it.next = it.next.next;
               if(nodeCount % 2 != 0) {
                   lastOddCache = it;
               }
               it = tmp;
               nodeCount++;
           }
           
           if(nodeCount % 2 == 0) {
               lastOddCache.next = evenHead;
           } else {
               it.next = evenHead;
           }
           return head;
       }
   }
   ```

3. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字，要求不能修改输入的数组，空间复杂度为O(1)，时间复杂度小于O(n^2)。#287

   > 基本思路：
   >
   > 该题与12-03题1雷同，难点在于不能修改输入的数组且空间复杂度为O(1)。

   ```java
   // TODO
   ```

## 2018-12-09

1. 输入一个二叉树，输出一个二维数组（List<List\<Integer\>>），要求数组的每一行都对应树的每一层级。#102

   > 基本思路：
   >
   > - 本题考查二叉树的层序遍历，可以借助队列（LinkedList）来实现树的层序遍历。
   > - 给节点增加level属性，表示节点在树中的层级，当第一次碰到下一个层级的节点时，往二维数组中增加一行。

   ```java
   class Solution {
       class TreeNodeWrapper {
           TreeNode node;
           int level;
           public TreeNodeWrapper (TreeNode node, int level) {
               this.node = node;
               this.level = level;
           }
       }
       public List<List<Integer>> levelOrder(TreeNode root) {
           Queue<TreeNodeWrapper> queue = new LinkedList<>();
           queue.offer(new TreeNodeWrapper(root, 1));
           List<List<Integer>> results = new ArrayList<>();
           int originLevel = 0;
           if(root == null)
               return results;
           while(!queue.isEmpty()) {
               int newLevel = 0;
               TreeNodeWrapper item = queue.poll();
               if(originLevel < item.level) {
                   List<Integer> result = new ArrayList<>();
                   results.add(result);
                   originLevel = item.level;
               }
               results.get(results.size() - 1).add(item.node.val);
               if(item.node.left != null) {
                   queue.offer(new TreeNodeWrapper(item.node.left, item.level + 1));
               }
               if(item.node.right != null) {
                   queue.offer(new TreeNodeWrapper(item.node.right, item.level + 1));
               }
           }
           return results;
       }
   }
   ```

2. （Star）在一个m*n的表格中，计算从 (1, 1) 到 (m, n) 的路径的数量。#62

   > 使用递归的方法：path(m, n) = path(m - 1, n) + path(m, n - 1) ；path(m, 1) = 1；path(1, n) = 1。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           if(m == 1 || n == 1) {
               return 1;
           }
           return uniquePaths(m, n - 1) + uniquePaths(m - 1, n);
       }
   }
   ```

   > 在LeetCode上提交后会发现：单纯使用递归会报Time Limit Exceed错误（超出时间限制），因为递归会重复进行同一个网点的计算（比如递归计算 path(3, 3) 时，无论 (2, 3) 还是 (3, 2)，都会重复计算 path(2, 2) ），并且递归会保留每一个函数的上下文对象，空间复杂度也很高。
   >
   > 优化方案是记录每一个网点的计算结果，在递归时进行判断，若该网点已经计算，直接返回值，否则再进行下一轮递归，这种办法叫**自顶向下的备忘录法**。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           return reversion(0, 0, paths);
       }
       
       public int reversion(int i, int j, int[][] array) {
           if(array[i][j] != 0)
               return array[i][j];
           if(i == array.length - 1
             || j == array[array.length - 1].length - 1) {
               array[i][j] = 1;
           } else {
               array[i][j] = reversion(i + 1, j, array) + reversion(i, j + 1, array);
           }
           return array[i][j];
       }
   }
   ```

   > 增加了备忘录后，计算Path(6, 6) 总归还是要计算到 Path(1, n) 和 Path(m, 1)的，为何不先从路径少的网点算起呢？
   >
   > DP的核心在于：先计算子问题，再由子问题计算父问题 。这就是**自底向上的动态规划**。在LeetCode上运行后会发现，动态规划（0ms，defeat 100%）比备忘录法（1ms，defeat 7%）的效率更高。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           for(int i = 0; i < m; i++) {
               paths[i][0] = 1;
           }
           
           for(int j = 0; j < n; j++) {
               paths[0][j] = 1;
           }
           for(int i = 1; i < m; i++) {
               for(int j = 1; j < n; j++) {
                   paths[i][j] = paths[i - 1][j] + paths[i][j -1];
               }
           }
           return paths[m - 1][n - 1];
       }
   }
   ```

3. 输入一个n*n的二维矩阵，将该矩阵顺时针旋转90度后输出。要求空间复杂度为O(1)。#48

   > 这是一个脑洞题，思路如下：
   >
   > 1. 将矩阵沿对角线对称翻转：transpose: swap(matrix\[i\][j], matrix\[j\][i])
   > 2. 将矩阵沿居中的y轴翻转：flip horizontally: swap(matrix\[i\][j], matrix\[i\][matrix.length - j - 1])

   ```java
   class Solution {
       public void rotate(int[][] matrix) {
           // 1. traspose: swap(matrix[i][j], matrix[j][i])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = i + 1; j < matrix.length; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[j][i];
                   matrix[j][i] = tmp;
               }
           }
           
           // 2. flip horizontally: swap(matrix[i][j], matrix[i][matrix.length - j - 1])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = 0; j < matrix.length / 2; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[i][matrix.length - j - 1];
                   matrix[i][matrix.length - j - 1] = tmp;
               }
           }
       }
   }
   ```


## 2018-12-10

1. 输入一个包含不同顺序短语的字符串数组（anagrams），要求将相同字符，但不同顺序的短语归成一组，输出List<List\<String>>。

   > 基本思路：
   >
   > 1. 遍历每个字符串，将其转换成char数组，对char数组排序（Arrays.sort），再转换成排序后的字符串。
   > 2. 查看临时缓存Map<String, List\<String>>中是否包含对应的key，并将字符串插入Map对应key的List\<String>中。
   > 3. 最后输出List<List\<String>>。（Map.values）

   ```java
   class Solution {
       public List<List<String>> groupAnagrams(String[] strs) {
           Map<String, List<String>> map = new HashMap<>();
           for(String s : strs) {
               char[] chars = s.toCharArray();
               Arrays.sort(chars);
               String ss = String.valueOf(chars);
               if(map.getOrDefault(ss, null) == null) map.put(ss, new ArrayList<String>());
               map.get(ss).add(s);
           }
           return new ArrayList<List<String>>(map.values());
       }
   }
   ```

2. Game of life. 输入一个二维数组，每个元素为0或1，代表细胞的生死。经过一个周期后，计算这些细胞的生死。细胞存活的规律如下：

   1. 若是死细胞，当周边8个细胞中有3个活细胞时，该细胞复活，否则继续死亡。
   2. 若是活细胞，当周边8个细胞中有2～3个活细胞时，该细胞继续存活，否则死亡。
   3. 要求solve it in-place，即不能开辟新的二维数组存储状态。

   > 基本思路：这是一道脑洞题，难点主要在in-place上。因为所有细胞都是同时转变，所以转变的规律是依靠四周细胞的旧状态来决定的。这就要求将新旧状态全都存储在一个int类型的数据中，规则如下：
   >
   > [2nd bit, 1st bit] -> [new state, old state]
   >
   > 然后遍历数组，统计每个细胞周边细胞旧状态下的存活数，计算出该细胞的新状态，并更新到数组中。



   ```java
   // clean code!
   class Solution {
       public void gameOfLife(int[][] board) {
           int m = board.length, n = board[0].length;
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   int lives = liveNum(board, i, j, m, n);
                   if(board[i][j] == 0 && lives == 3) {
                       board[i][j] = 2;
                   }
                   
                   if(board[i][j] == 1 && lives >= 2 && lives <= 3) {
                       board[i][j] = 3;
                   }
               }
           }
           
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   board[i][j] >>= 1;
               }
           }
       }
       
       private int liveNum(int[][] board, int i, int j, int m, int n) {
           int lives = 0;
           for(int x = Math.max(0, i - 1); x <= Math.min(i + 1, m - 1); x++) {
               for(int y = Math.max(0, j - 1); y <= Math.min(j + 1, n - 1); y++) {
                   lives += board[x][y] & 1;
               }
           }
           lives -= board[i][j] & 1;
           return lives;
       }
   }
   ```


## 2018-12-11