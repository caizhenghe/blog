# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          List<Integer> output = new ArrayList<Integer>();
          public List<Integer> inorderTraversal(TreeNode root) {
              if(root == null) {
                  return output;
              }
              inorderTraversal(root.left);
              output.add(root.val);
              inorderTraversal(root.right);
              return output;
          }
      }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```


## 2018-12-04

1. （Star）输入一个数组，输出该数组的所有序列List<List\<Integer\>>。#46

   > 基本思路：
   >
   > 1. n个数的数组有n\*(n-1)\*...\*2\*1种组合。
   > 2. 当a添加至包含n-1个数的数组时，将a与数组中的每个数替换，都会有(n-1)\*(n-2)\*…1种组合，最终形成第一点所说的组合数目。
   >
   > Tips：List的addAll和clone都是浅拷贝，每个元素都指向同一块内存地址。



   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> results = new ArrayList<List<Integer>>();
           
           permuteRecursion(results, nums, 0, nums.length - 1);
           
           return results;
       }
       
       public void permuteRecursion(List<List<Integer>> results, int[] nums, int start, int end) {
           if(start == end) {
               List<Integer> result = new ArrayList<Integer>();
               for (int num : nums) {
                   result.add(num);
               }
               results.add(result);
           } else {
               for(int i = start; i <= end; i++) {
                   nums = swap(nums, start, i);
                   permuteRecursion(results, nums, start + 1, end);
                   nums = swap(nums, start, i);
               }
           }
       }
       
       public int[] swap(int[] nums, int first, int second) {
           int c = nums[first];
           nums[first] = nums[second];
           nums[second] = c;
           
           return nums;
       }
   }
   ```

2. （Good）输入n，输出所有可能的括号排序List\<String\>，要求左右括号一一对应。#22

   > Tips：String、StringBuffer、StringBuilder的区别：（TODO）
   >
   > 修改String的值本质上是给它分配了一块新的内存地址；StringBuffer的append方法则是在原来的内存地址上修改值。
   >
   > 基本思路：
   >
   > 1. 剩余左括号的数量小于等于剩余右括号的数量。
   > 2. 使用递归的思路，当剩余左括号为0时，append所有剩余右括号；当剩余左括号等于右括号时，append左括号并递归；其余情况分别append左括号和右括号并递归（append右括号时需要往List中添加新的字符串）。



   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<StringBuffer> tmp = new ArrayList<StringBuffer>();
           StringBuffer sb = new StringBuffer("");
           tmp.add(sb);
           recursion(tmp, sb, n, n);
   
           List<String> result = new ArrayList<String>();
           for(StringBuffer item : tmp) {
               result.add(item.toString());
           }
           return result;
       }
   
       public void recursion(List<StringBuffer> list, StringBuffer s, int left, int right) {
           if (left == 0) {
               while(right > 0) {
                   s.append(")");
                   right--;
               }
           }
           else if(left == right) {
               s.append("(");
               recursion(list, s, left - 1, right);
           } else {
               StringBuffer tmp = new StringBuffer(s.toString());
               s.append("(");
               recursion(list, s, left - 1, right);
               list.add(tmp.append(")"));
               recursion(list, tmp, left, right - 1);
           }
       }
   }
   ```


## 2018-12-05

1. 输入一个无重复元素的数组（distinct integers），输出所有的子集List<List\<Integer\>>，要求子集不能有重复。#78

   > 基本思路：找规律，假设已经得到nums[0～n-1]的子集Subset1，深拷贝一份子集Subset2，再将nums[n]加入Subset2的每个元素中即可。



   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> results = new ArrayList<>();
           results.add(new ArrayList<Integer>());
           if(nums == null || nums.length == 0)
               return results;
           int end = 0;
           while(end < nums.length) {
               int originSize = results.size();
               results.addAll(deepClone(results));
               for(int i = originSize; i < results.size(); i++) {
                   results.get(i).add(nums[end]);
               };
               end++;
           }
           return results;
       }
       
       public List<List<Integer>> deepClone(List<List<Integer>> reses) {
           List<List<Integer>> results = new ArrayList<>();
           for(List<Integer> res : reses) {
               List<Integer> result = new ArrayList<>();
               for(Integer i : res) {
                   result.add(i);
               }
               results.add(result);
           }
           return results;
       }
   }
   ```

2. （Good）输入BST的根节点和k，返回BST中第k小的元素。#230

   > Tips：
   >
   > 1. BST（二叉搜索树）的概念：左子节点<根节点<右子节点。
   > 2. B树、B+树、B-树、B*树的概念。（TODO）
   >
   > 基本思路：
   >
   > BST中，中序遍历BST，第k个节点就是Kth smallest element。



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public int kthSmallest(TreeNode root, int k) {
           List<Integer> result = new ArrayList<Integer>();
           recursion(root, result, k);
           return result.get(k - 1);
       }
       
       public void recursion(TreeNode root, List<Integer> list, int k) {
           if(root == null || list.size() >= k)
               return;
           recursion(root.left, list, k);
           list.add(root.val);
           recursion(root.right, list, k);
       }
   }
   ```


## 2018-12-06

1. 输入两个链表，输出一个链表，要求每个元素是输入链表对应位置元素之和，包含进位。#2

   ```java
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           ListNode node = new ListNode(0);
           ListNode iterator = node;
           int add = 0;
           while (l1 != null || l2 != null || add > 0) {
               int x = 0, y = 0, all = 0;
               if (l1 != null) {
                   x = l1.val;
                   l1 = l1.next;
               }
   
               if (l2 != null) {
                   y = l2.val;
                   l2 = l2.next;
               }
   
               all = x + y + add;
               add = all / 10;
               iterator.val = all % 10;
               if (l1 != null || l2 != null || add > 0)
                   iterator.next = new ListNode(0);
               iterator = iterator.next;
           }
           return node;
       }
   }
   ```

2. （Good）输入一个字符串，输出其中不重复的连续子字符串的最大长度。#3

   > 基本思路：
   >
   > 1. 使用Map，其中key表示字符，value表示字符出现的顺序索引，记录一个不重复子串的初始索引。遍历字符串，若字符索引大于等于初始索引，说明该字符已经存在，更新最大长度和当前子串长度，更新初始索引，并对该字符记录新的索引；若该字符不存在， ，并对该字符记录索引。
   > 2. 若使用Hash数组代替Map，使用数组下标代替key，需要开辟能够包含所有ASC字符的数组（ASC表长度为177）。
   > 3. Discuss其余思路（TODO）



   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           if(s == null || s.equals(""))
               return 0;
           int[] hash = new int[178];
           int max = 0, length = 0, validIndex = 100;
           for(int i = 0; i < s.length(); i++) {
               char c = s.charAt(i);
               int index = hash[c - '\0'];
               if(index >= validIndex) {
                   max = Math.max(max, length);
                   length = length - (index - validIndex);
                   validIndex = index + 1;
               } else {
                   length++;
               }
               hash[c - '\0'] = validIndex + length - 1;
   
           }
           return Math.max(max, length);
       }
   }
   ```


## 2018-12-08

1. （Star）求有序二维矩阵中的第k小的值。#378

   > 基础知识点：
   >
   > 1. 堆排序：要求子节点比父节点大/小，根节点最大/小。每次插入元素后堆重新排序，排序后依然满足前述特点。
   > 2. PriorityQueue：有序队列，内部使用堆排序的方式排列数据，有以下特点：
   >    - 不满足FIFO（先入先出，队尾插入队首移除）。
   >    - 直接打印队列时数据是无序的，只能保证队首元素最大/最小。遍历出栈的数据是有序的。
   >    - PriorityQueue有两种排序方式：
   >      - 自然排序：按元素的大小排序，数据以升序的方式出列。
   >      - 定制排序：复写Comparator\<T\>接口，元素的compareTo方法返回负数时，堆重新排序，将该元素放到队首；返回正数时，直接将元素插到队尾，不重新排序。
   >    - poll/offer和remove/add的区别：
   >      - 当队列为空时，poll直接返回null，remove抛出异常。
   >      - 当队列为满时，offer直接返回false，而add返回uncheck异常。
   >    - peek和element的区别：两者均是搜索队首元素，但不将其出列。当队列为空时，peek返回null，element抛出异常。
   >
   >
   >
   > 基本思路：
   >
   > 1. 每个元素需要记录自身的位置（x,y），借助PriorityQueue进行排序，要求队首元素最小。
   > 2. 将二维矩阵的第一行元素入列。
   > 3. 遍历k-1次，每次遍历时出列一个元素（x,y），并将（x，y+1）元素入列（当y到达最后一行时，直接出列下一个元素）。
   > 4. 出列k-1个元素后，下个元素就是Kth smallest。



   ```java
   class Solution {
           class Tuple implements Comparable<Tuple> {
               int x;
               int y;
               int val;
   
               public Tuple(int x, int y, int val) {
                   this.x = x;
                   this.y = y;
                   this.val = val;
               }
   
   
               @Override
               public int compareTo(Tuple o) {
                   return this.val - o.val;
               }
           }
   
           public int kthSmallest(int[][] matrix, int k) {
               int n = matrix.length;
               PriorityQueue<Tuple> queue = new PriorityQueue<>();
               for (int i = 0; i < n; i++) {
                   queue.offer(new Tuple(i, 0, matrix[i][0]));
               }
   
               for (int i = 0; i < k - 1; i++) {
                   Tuple e = queue.poll();
                   if (e.y == n - 1) continue;
                   queue.offer(new Tuple(e.x, e.y + 1, matrix[e.x][e.y + 1]));
               }
               return queue.poll().val;
           }
       }
   ```

2. 将一个链表重新排序，要求奇数下标的节点相连，偶数下标的节点相连，最后将偶数节点链表接在奇数节点链表后面。要求空间复杂度为O(1)，时间复杂度为O(n)。#328

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode oddEvenList(ListNode head) {
           if(head == null)
               return null;
           
           ListNode evenHead = head.next;
           ListNode lastOddCache = null;
           ListNode it = head;
           int nodeCount = 1;
           while(it.next != null) {
               ListNode tmp = it.next;
               it.next = it.next.next;
               if(nodeCount % 2 != 0) {
                   lastOddCache = it;
               }
               it = tmp;
               nodeCount++;
           }
           
           if(nodeCount % 2 == 0) {
               lastOddCache.next = evenHead;
           } else {
               it.next = evenHead;
           }
           return head;
       }
   }
   ```

3. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字，要求不能修改输入的数组，空间复杂度为O(1)，时间复杂度小于O(n^2)。#287

   > 基本思路：
   >
   > 该题与12-03题1雷同，难点在于不能修改输入的数组且空间复杂度为O(1)。

   ```java
   // TODO
   ```

## 2018-12-09

1. 输入一个二叉树，输出一个二维数组（List<List\<Integer\>>），要求数组的每一行都对应树的每一层级。#102

   > 基本思路：
   >
   > - 本题考查二叉树的层序遍历，可以借助队列（LinkedList）来实现树的层序遍历。
   > - 给节点增加level属性，表示节点在树中的层级，当第一次碰到下一个层级的节点时，往二维数组中增加一行。

   ```java
   class Solution {
       class TreeNodeWrapper {
           TreeNode node;
           int level;
           public TreeNodeWrapper (TreeNode node, int level) {
               this.node = node;
               this.level = level;
           }
       }
       public List<List<Integer>> levelOrder(TreeNode root) {
           Queue<TreeNodeWrapper> queue = new LinkedList<>();
           queue.offer(new TreeNodeWrapper(root, 1));
           List<List<Integer>> results = new ArrayList<>();
           int originLevel = 0;
           if(root == null)
               return results;
           while(!queue.isEmpty()) {
               int newLevel = 0;
               TreeNodeWrapper item = queue.poll();
               if(originLevel < item.level) {
                   List<Integer> result = new ArrayList<>();
                   results.add(result);
                   originLevel = item.level;
               }
               results.get(results.size() - 1).add(item.node.val);
               if(item.node.left != null) {
                   queue.offer(new TreeNodeWrapper(item.node.left, item.level + 1));
               }
               if(item.node.right != null) {
                   queue.offer(new TreeNodeWrapper(item.node.right, item.level + 1));
               }
           }
           return results;
       }
   }
   ```

2. （Star）在一个m*n的表格中，计算从 (1, 1) 到 (m, n) 的路径的数量。#62

   > 使用递归的方法：path(m, n) = path(m - 1, n) + path(m, n - 1) ；path(m, 1) = 1；path(1, n) = 1。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           if(m == 1 || n == 1) {
               return 1;
           }
           return uniquePaths(m, n - 1) + uniquePaths(m - 1, n);
       }
   }
   ```

   > 在LeetCode上提交后会发现：单纯使用递归会报Time Limit Exceed错误（超出时间限制），因为递归会重复进行同一个网点的计算（比如递归计算 path(3, 3) 时，无论 (2, 3) 还是 (3, 2)，都会重复计算 path(2, 2) ），并且递归会保留每一个函数的上下文对象，空间复杂度也很高。
   >
   > 优化方案是记录每一个网点的计算结果，在递归时进行判断，若该网点已经计算，直接返回值，否则再进行下一轮递归，这种办法叫**自顶向下的备忘录法**。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           return reversion(m, n, paths);
       }
       
       public int reversion(int m, int n, int[][] array) {
           if(array[m - 1][n - 1] != 0)
               return array[m - 1][n - 1];
           if(m == 1 || n == 1) {
               array[m - 1][n - 1] = 1;
           } else {
               array[m - 1][n - 1] = reversion(m, n -1, array) + reversion(m - 1, n, array);
           }
           return array[m - 1][n - 1];
       }
   }
   ```

   > 增加了备忘录后，计算Path(6, 6) 总归还是要计算到 Path(1, n) 和 Path(m, 1)的，为何不先从路径少的网点算起呢？
   >
   > DP的核心在于：先计算子问题，再由子问题计算父问题 。这就是**自底向上的动态规划**。在LeetCode上运行后会发现，动态规划（0ms，defeat 100%）比备忘录法（1ms，defeat 7%）的效率更高。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           for(int i = 0; i < m; i++) {
               paths[i][0] = 1;
           }
           
           for(int j = 0; j < n; j++) {
               paths[0][j] = 1;
           }
           for(int i = 1; i < m; i++) {
               for(int j = 1; j < n; j++) {
                   paths[i][j] = paths[i - 1][j] + paths[i][j -1];
               }
           }
           return paths[m - 1][n - 1];
       }
   }
   ```

3. 输入一个n*n的二维矩阵，将该矩阵顺时针旋转90度后输出。要求空间复杂度为O(1)。#48

   > 这是一个脑洞题，思路如下：
   >
   > 1. 将矩阵沿对角线对称翻转：transpose: swap(matrix\[i\][j], matrix\[j\][i])
   > 2. 将矩阵沿居中的y轴翻转：flip horizontally: swap(matrix\[i\][j], matrix\[i\][matrix.length - j - 1])

   ```java
   class Solution {
       public void rotate(int[][] matrix) {
           // 1. traspose: swap(matrix[i][j], matrix[j][i])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = i + 1; j < matrix.length; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[j][i];
                   matrix[j][i] = tmp;
               }
           }
           
           // 2. flip horizontally: swap(matrix[i][j], matrix[i][matrix.length - j - 1])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = 0; j < matrix.length / 2; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[i][matrix.length - j - 1];
                   matrix[i][matrix.length - j - 1] = tmp;
               }
           }
       }
   }
   ```


## 2018-12-10

1. 输入一个包含不同顺序短语的字符串数组（anagrams），要求将相同字符，但不同顺序的短语归成一组，输出List<List\<String>>。#49

   > 基本思路：
   >
   > 1. 遍历每个字符串，将其转换成char数组，对char数组排序（Arrays.sort），再转换成排序后的字符串。
   > 2. 查看临时缓存Map<String, List\<String>>中是否包含对应的key，并将字符串插入Map对应key的List\<String>中。
   > 3. 最后输出List<List\<String>>。（Map.values）

   ```java
   class Solution {
       public List<List<String>> groupAnagrams(String[] strs) {
           Map<String, List<String>> map = new HashMap<>();
           for(String s : strs) {
               char[] chars = s.toCharArray();
               Arrays.sort(chars);
               String ss = String.valueOf(chars);
               if(map.getOrDefault(ss, null) == null) map.put(ss, new ArrayList<String>());
               map.get(ss).add(s);
           }
           return new ArrayList<List<String>>(map.values());
       }
   }
   ```

2. Game of life #289. 输入一个二维数组，每个元素为0或1，代表细胞的生死。经过一个周期后，计算这些细胞的生死。细胞存活的规律如下：

   1. 若是死细胞，当周边8个细胞中有3个活细胞时，该细胞复活，否则继续死亡。
   2. 若是活细胞，当周边8个细胞中有2～3个活细胞时，该细胞继续存活，否则死亡。
   3. 要求solve it in-place，即不能开辟新的二维数组存储状态。

   > 基本思路：这是一道脑洞题，难点主要在in-place上。因为所有细胞都是同时转变，所以转变的规律是依靠四周细胞的旧状态来决定的。这就要求将新旧状态全都存储在一个int类型的数据中，规则如下：
   >
   > [2nd bit, 1st bit] -> [new state, old state]
   >
   > 然后遍历数组，统计每个细胞周边细胞旧状态下的存活数，计算出该细胞的新状态，并更新到数组中。



   ```java
   // clean code!
   class Solution {
       public void gameOfLife(int[][] board) {
           int m = board.length, n = board[0].length;
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   int lives = liveNum(board, i, j, m, n);
                   if(board[i][j] == 0 && lives == 3) {
                       board[i][j] = 2;
                   }
                   
                   if(board[i][j] == 1 && lives >= 2 && lives <= 3) {
                       board[i][j] = 3;
                   }
               }
           }
           
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   board[i][j] >>= 1;
               }
           }
       }
       
       private int liveNum(int[][] board, int i, int j, int m, int n) {
           int lives = 0;
           for(int x = Math.max(0, i - 1); x <= Math.min(i + 1, m - 1); x++) {
               for(int y = Math.max(0, j - 1); y <= Math.min(j + 1, n - 1); y++) {
                   lives += board[x][y] & 1;
               }
           }
           lives -= board[i][j] & 1;
           return lives;
       }
   }
   ```


## 2018-12-11

1. 设计一个数据集合，实现数据的增删改查以及获取随机数功能。#380

   > 基本思路：利用HashSet来实现增删改查，利用Math.random来获取随机数据。
   >
   > TODO：
   >
   > 1. 了解HashSet和HashMap的内部实现。
   > 2. 如果要支持多线程，该如何优化该数据集（ConcurrentHashMap）。
   > 3. better discussing。



   ```java
   class RandomizedSet {
       Set<Integer> data;
   
       /**
        * Initialize your data structure here.
        */
       public RandomizedSet() {
           data = new HashSet<>();
       }
   
       /**
        * Inserts a value to the set. Returns true if the set did not already contain the specified element.
        */
       public boolean insert(int val) {
           if (data.contains(val))
               return false;
           else
               data.add(val);
           return true;
       }
   
       /**
        * Removes a value from the set. Returns true if the set contained the specified element.
        */
       public boolean remove(int val) {
           if (!data.contains(val))
               return false;
           else
               data.remove(val);
           return true;
       }
   
       /**
        * Get a random element from the set.
        */
       public int getRandom() {
           double random = Math.random();
           Integer[] array = new Integer[data.size()];
           array = data.toArray(array);
           return array[(int) (data.size() * random)];
       }
   }
   ```

2. 给定n个非负整数a1，a2，...，an，每个整数代表坐标（i，ai）处的一个点。 绘制n条垂直线，使得线i的两个端点处于（i，ai）和（i，0）处。 找到两条线，它们与x轴一起形成一个容器，以使容器包含最多的水。#11

   > 基本思路：
   >
   > 1. 最简单的做法是双重遍历，时间复杂度为O(nlogn)，分别计算每个容器的面积并返回最大面积。
   > 2. 利用贪婪算法，只计算局部最优解，不可回溯，在上一步的局部最优解基础上进行下一步计算，可能会错过全局最优解，但是可以有效减少判断次数。



   ```java
   // normal solution
   class Solution {
       public int maxArea(int[] height) {
           int maxS = 0;
           for(int i = 0; i < height.length; i++) {
               for(int j = i + 1; j < height.length; j++) {
                   int s = Math.min(height[i], height[j]) * (j - i);
                   maxS = Math.max(s, maxS);
               }
           }
           return maxS;
       }
   }
   
   // greedy solution，move left/right when val(left/right) is smaller in once foreach.
   class Solution {
       public int maxArea(int[] height) {
           int i = 0, j = height.length - 1, max = 0;
           while(j >= i) {
               int s = Math.min(height[i], height[j]) * (j - i);
               max = Math.max(s, max);
               if(height[i] > height[j])
                   j--;
               else
                   i++;
           }
           return max;
       }
   }
   ```


## 2018-12-13

1. Jump game. 给定一个数组N，从第i个元素最多可以跳到第N[i] + i个元素，以此类推，输出结果：是否可以跳到数组的尾部。#55. Greedy

   > 基本思路：本题本质上是考察是否可以避开数组中值为0的元素，下面给出两种解法。



   ```java
   // 1. 记录可以跳的最远距离
   class Solution {
       public boolean canJump(int[] nums) {
           int max = 0;
           for(int i = 1; i < nums.length; i++) {
               // 前一个元素值为0且前置位元素跳的最远距离都到达不了当前元素时返回false。
               if(nums[i - 1] == 0 && i > nums[max] + max) {
                   return false;
               }
               // 更新跳的最远的元素下标。
               max = i + nums[i] > max + nums[max] ? i : max;
           }
           return true;
       }
   }
   
   // 2. 遍历查找是否有规避值为0的元素的方法。
   public class Solution {
       public boolean canJump(int[] nums) {
           if (nums.length < 2)
               return true;
           search : for (int i = nums.length - 2; i >= 0; i--) {
               if (nums[i] == 0) {
                   // 从值为0的元素往前找，若所有元素均跳不到i则返回false，不然直接从第一层循环开始下一次遍历
                   for (int j = i - 1; j >= 0; j--) {
                       if (nums[j] > i - j) {
                           i = j;
                           continue search;
                       }
                   }
                   return false;
               }
           }
           return true;
       }
   }
   ```

2. 假设"()"是一对有效括号，现给定一组乱序排列的括号字符串，求添加几个圆括号可以使该字符串内部全部变成有效括号。#921. Greedy

   > 基本思路：本题不仅仅是计算左括号和右括号的个数，还要注意括号的顺序，比如")))((("返回6，而"((()))"则返回0。



   ```java
   class Solution {
       public int minAddToMakeValid(String S) {
           if(S == null || S.length() == 0)
               return 0;
           int left = 0, right = 0, count = 0;
           char[] array = S.toCharArray();
           for(char c : array) {
               if(c == '(') {
                   left++;
                   count++;
               } else {
                   right++;
                   if(right > left) {
                       // 当右括号比左括号多时，count++。由于这些右括号是无效括号，不计入right，避免影响后续计算：例如")()"。
                       count++;
                       right--;
                   } else {
                       count--;
                   }
               }
           }
           return Math.abs(count);
       }
   }
   ```

3. 输入一个9*9的数独数组，判断该数组是否合法（合法数独的行、列、9宫格中的数字均不重复）。#36

   > 基础思路：
   >
   > 1. 本题主要考察如何同时遍历数组的行、列和九宫格。
   > 2. 可以采用三个Set分别存储一行、一列、一个九宫格的数据，Set.add若返回true则表示已存在该数据。

   ```java
   class Solution {
       public boolean isValidSudoku(char[][] board) {
           for(int i = 0; i < 9; i++) {
               Set<Character> row = new HashSet<Character>();
               Set<Character> column = new HashSet<Character>();
               Set<Character> cube = new HashSet<Character>();
               for(int j = 0; j < 9; j++) {
                   if(board[i][j] != '.' && !row.add(board[i][j])) {
                       return false;
                   }
                   if(board[j][i] != '.' && !column.add(board[j][i])) {
                       return false;
                   }
                   // rowIndex, columnIndex表示每个九宫格首元素的(x,y)坐标
                   int rowIndex = i/3*3;
                   int columnIndex = i%3*3;
                   if(board[rowIndex+j/3][columnIndex+j%3]!='.' && !cube.add(board[rowIndex+j/3][columnIndex+j%3])) {
                       return false;
                   }
               }
           }
           return true;
       }
   }
   ```

## 2018-12-14

1. 输入包含0,1,2的乱序数组，输出按照1->0->2排序的有序数组。要求不能使用Arrays.sort方法，空间复杂度为O（1）。不建议使用如下做法：遍历数组，分别记录数组中0,1,2的个数，再填充至数组中。#75

   > 基本思路：本题本质上就是将1放到数组的前面，2放到数组的后面，0就留在数组的中间。

   ```java
   class Solution {
       public void sortColors(int[] nums) {
           int one = 0, two = nums.length - 1;
           // 为了减少遍历次数，可以将i<nums.length改成i<=two
           for(int i = 0; i < nums.length; i++) {
               // 若扫描到2，则将i和two上的元素互换位置并执行two--，使用while是因为换到i上的元素值可能依然是2.
               while(nums[i] == 2 && i < two) swap(i, two--, nums);
               while(nums[i] == 1 && i > one) swap(i, one++, nums);
           }
       }
   
       private void swap(int a, int b, int[] nums) {
           int tmp = nums[a];
           nums[a] = nums[b];
           nums[b] = tmp;
       }
   }
   ```

2. 找到数组中的一个峰值，要求该峰值比左右两边的值都大，第一个元素左边和最后一个元素右边的值默认为负无穷。#162

   ```java
   class Solution {
       public int findPeakElement(int[] nums) {
           int result = -1;
           if(nums == null || nums.length == 0)
               return -1;
           if(nums.length == 1)
               return 0;
           for(int i = 0; i < nums.length; i++) {
               if(nums[i] >= nums[Math.max(i-1, 0)] && nums[i] >= nums[Math.min(i+1, nums.length - 1)]) {
                   result = i;
                   break;
               }
           }
           return result;
       }
   }
   ```

3. 输入一个m*n的二维数组，每一行、每一列数字均为升序排列，求数组中是否存在给定的target。

   > 基本思路：
   >
   > 1. 与#378类似，借助PriorityQueue，从小到大依次输出数组中的元素，查询是否有与target相等的值。但是采用该种方法LeetCode会报Time Limit Exceeded错误。
   > 2. better discuss（TODO）

   ```java
   // 1. priority queue
   class Solution {
       class Tuple implements Comparable<Tuple> {
           int x;
           int y;
           int val;
   
           public Tuple(int x, int y, int val) {
               this.x = x;
               this.y = y;
               this.val = val;
           }
   
           @Override
           public int compareTo(Tuple o) {
               return this.val - o.val;
           }
       }
   
       public boolean searchMatrix(int[][] matrix, int target) {
           int row = matrix.length;
           if(matrix == null || matrix.length == 0) return false;
           int column = matrix[0].length;
           if(column == 0) return false;
           Queue<Tuple> queue = new PriorityQueue<>();
           for (int i = 0; i < column; i++) {
               queue.offer(new Tuple(0, i, matrix[0][i]));
           }
           Tuple o = new Tuple(0, 0, matrix[0][0]);
           if (o.val == target) return true;
           while (o.val < target) {
               o = queue.poll();
               if(o == null) return false;
               if (o.val == target) return true;
               if (o.x >= row - 1) continue;
               queue.offer(new Tuple(o.x + 1, o.y, matrix[o.x + 1][o.y]));
           }
           return false;
       }
   }
   
   // 2. better discuss
   public class Solution {
       public boolean searchMatrix(int[][] matrix, int target) {
           if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
               return false;
           }
           int col = matrix[0].length-1;
           int row = 0;
           while(col >= 0 && row <= matrix.length-1) {
               if(target == matrix[row][col]) {
                   return true;
               } else if(target < matrix[row][col]) {
                   col--;
               } else if(target > matrix[row][col]) {
                   row++;
               }
           }
           return false;
       }
   }
   ```



## 2018-12-17

1. （Star）输入一个无序数组，求最长递增子序列的长度（子序列可以不连续：Subsequence）。#300

   > 基本思路：本题采用DP思想，记录每个Index下的最长子序列数组dp[]。

   ```java
   class Solution {
       public int lengthOfLIS(int[] nums) {
           int max = 0;
           int[] dp = new int[nums.length];
           for(int i = 0; i < nums.length; i++) {
               // 最长子序列dp[i]初始为1，遍历nums[]中i位置之前的所有元素，若nums[j]<nums[i]，则更新最长子序列dp[i]的值。
               dp[i] = 1;
               for(int j = 0; j < i; j++) {
                   if(nums[j] < nums[i]) {
                       dp[i] = Math.max(dp[j] + 1, dp[i]);
                   }
               }
               // 记录i位置的最长子序列长度之后，更新整个数组的最长子序列长度。
               max = Math.max(dp[i], max);
           }
           return max;
       }
   }
   ```

2. （Star）输入一个数，代表正方形的面积之和（1，4，9…），求最少需要几个正方形？#279

   > 基本思路：该题依旧是DP思想，创建一个记录min square的数组dp[]，依次计算小于等于n的数的最少正方形数量。计算数n时，使用m遍历1~n，**比较dp[n]和dp[n-m*m]+1**，取最小值。

   ```java
   class Solution {
       public int numSquares(int n) {
           int[] dp = new int[n+1];
           dp[1] = 1;
           for(int i = 2; i <= n; i++) {
               for(int j = 1; j*j <= i; j++) {
                   // if dp[i] not be assigned before, just assigned by dp[i-j*j]+1
                   if(dp[i] > 0) {
                       dp[i] = Math.min(dp[i], dp[i - j*j] + 1);    
                   }else{
                       dp[i] = dp[i - j*j] + 1;
                   }
               }
           }
           return dp[n];
       }
   }
   ```

3. （Good）输入一个二叉树，蜿蜒输出二叉树中每一层的值。#103

   > 基本思路：
   >
   > 该题与12-09题一（#102）雷同，利用队列对二叉树进行层序遍历，区别在于偶数层插入List时采用List.add(val)；奇数层插入List时采用List.add(0, val)。

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       class NodeWrapper{
           TreeNode node;
           int level;
           
           NodeWrapper(TreeNode node, int depth) {
               this.node = node;
               this.level = depth;
           }
       }
       public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
           Queue<NodeWrapper> queue = new LinkedList<>();
           List<List<Integer>> result = new ArrayList<List<Integer>>();
           if(root == null)
               return result;
           queue.offer(new NodeWrapper(root, 0));
           int originLevel = -1;
           List<Integer> levelArray = null;
           while(!queue.isEmpty()) {
               NodeWrapper wrapper = queue.poll();
               
               if(wrapper.level != originLevel) {
                   levelArray = new ArrayList<Integer>();
                   result.add(levelArray);
                   originLevel = wrapper.level;
               }
               if(wrapper.level % 2 == 0) levelArray.add(wrapper.node.val);
               else levelArray.add(0, wrapper.node.val);
               
               if(wrapper.node.left != null) queue.offer(new NodeWrapper(wrapper.node.left, originLevel + 1));
               if(wrapper.node.right != null) queue.offer(new NodeWrapper(wrapper.node.right, originLevel + 1));
           }
           return result;
       }
   }
   ```

## 2018-12-18

1. 输入一个无序数组，问是否包含长度为3的递增子序列（子序列可以不连续：Subsequence）。#334

   > 基本思路：本题和12-17 题一（#300）类似，使用DP思想，当dp[i]或max大于等于3时，返回true；否则返回false。
   >
   > TODO：better discuss

   ```java
   class Solution {
       public boolean increasingTriplet(int[] nums) {
           int max = 1;
           int[] dp = new int[nums.length];
           if(nums.length < 3)
               return false;
   
           for(int i = 0; i < nums.length; i++) {
               dp[i] = 1;
               for(int j = 0; j < i; j++) {
                   if(nums[j] < nums[i]) {
                       dp[i] = Math.max(dp[j] + 1, dp[i]);
                       if(dp[i]>=3) return true;
                   }
               }
               max = Math.max(max, dp[i]);
               if(max >= 3) return true;
           }
           return false;
       }
   }
   ```

2. 输入一个数组[2,3]，输出2,3在手机九宫格中代表的字符的所有组合："ad","ae","af","bd"…… #17

   > 基本思路：本题和12-05 题一（#78）类似，每添加一个数字深拷贝n次集合（n为新增数字对应的字符数），将新增字符添加至对应的条目中。
   >
   > TODO：better discuss

   ```java
   class Solution {
       // 下标为九宫格数字，value为数字对应的letter字符串
       String letters[] = new String[]{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
       public List<String> letterCombinations(String digits) {
           List<String> output = new ArrayList<>();
           for(char digit : digits.toCharArray()) {
               append(output, digit);
           }
   
           return output;
       }
   
       private void append(List<String> output, char digit) {
           char[] letterArray = letters[digit - '2'].toCharArray();
   
           List<String> origin = deepClone(output);
   
           if(origin.size()==0) {
               // 初次添加时，直接将letter字符串中的每个字符插入列表中
               for(int i = 0; i < letterArray.length; i++) {
                   output.add(new String(Character.toString(letterArray[i])));
               }
           }else{
               // 后续添加时，深拷贝列表（假如列表size为m）n次（n为letter字符串中的字符数）。将字符0加入条目0~m-1，字符1加入条目m~2*m-1，字符n加入条目m*n~m*(n+1)-1
               for(int i = 0; i < letterArray.length - 1; i++) {
                   output.addAll(deepClone(origin));
               }
               for(int i = 0; i < output.size(); i++) {
                   String s = output.get(i);
                   output.set(i, s + Character.toString(letterArray[i / origin.size()]));
               }
           }
       }
   
       private List<String> deepClone(List<String> letters) {
           List<String> output = new ArrayList<String>();
           for(String s : letters) {
               String ss = new String(s);
               output.add(ss);
           }
           return output;
       }
   }
   ```

3. 输入一个二维数组，已知1为陆地，0为水，被水环绕的陆地为岛屿，求数组中有几个岛屿。#200

   > 基本思路：这是一道脑洞题。遍历二维数组，当遇上陆地时将与其相连的所有陆地均置位0（递归），并自增岛屿数量，最终求得的就是总岛屿数。

   ```java
   class Solution {
       public int numIslands(char[][] grid) {
           if(grid == null || grid.length == 0)
               return 0;
           int m = grid.length, n = grid[0].length;
           int result = 0;
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   if(grid[i][j] == '1') {
                       removeIsland(grid, i, j, m, n);
                       result++;
                   }
               }
           }
           return result;
       }
       private void removeIsland(char[][] grid, int i, int j, int m, int n) {
           if(i<0 || j < 0 || i >= m || j >= n || grid[i][j] != '1') return;
           grid[i][j]=0;
           removeIsland(grid, i-1, j, m, n);        
           removeIsland(grid, i+1, j, m, n);
           removeIsland(grid, i, j-1, m, n);
           removeIsland(grid, i, j+1, m, n);
       }
   }
   ```

4. （Star）输入一个字符串，输出该字符串的所有回文子串集合。例如：输入"aab",输出[["a","a","b"], ["aa","b"]]。#131

   > Tips：
   >
   > 1. 回文：一个字符串正读和倒读一致，则称为回文字符串（Palindrome）。
   >
   > 2. DFS：depth first search，深度优先遍历，例如二叉树的先序遍历、中序遍历、后序遍历。
   >
   >    BFS；breadth first search，广度优先遍历，例如二叉树的层序遍历。
   >
   > 3. String对象的substring(startIndex, endIndex)方法：endIndex表示末尾之后一位的索引。比如取String a的首元素，调用a.substring(0, 1)。
   >
   > 4. ArrayList对象的clone方法：浅拷贝。新建一个数组对象，该数组与原数组指向同一批对象。通常适用于只add/remove元素，但不修改元素内容的场景。若想要修改元素内容，且不希望影响到其他数组，则需要使用深拷贝。
   >
   > 基本思路：
   >
   > 本题使用DFS思想，使用List\<String\>cur记录当前的子串集合，当某个子串是回文时，插入cur，若回溯到最后每个子串均插入到了cur中，则将cur.clone插入结果中。每轮遍历结束，将cur末尾的子串移除，进行下一轮遍历。

   ```java
   class Solution {
       List<List<String>> results = new ArrayList<>();
       List<String> cur = new ArrayList<>();
       public List<List<String>> partition(String s) {
           dfs(s, 0);
           return results;
       }
       
       private void dfs(String s, int left) {
           for(int i = left; i < s.length(); i++) {
               String sub = s.substring(left, i+1);
               if(check(sub)) {
                   cur.add(sub);
                   dfs(s, i+1);
                   cur.remove(cur.size() - 1);
               }
           }
           if(cur.size() > 0 && left>=s.length()) {
               List<String> clone = (List<String>) ((ArrayList<String>) cur).clone();
               results.add(clone);
           }
       }
       
       private boolean check(String s) {
           return s.equals(new StringBuffer(s).reverse().toString());
       }
   }
   ```

5. 输入一个二维数组matrix，若matrix[i][j\]为0，则将该数所在的行和列均置为0，要求空间复杂度为O(1)。#73

   > 基本思路：本题乍一看类似于12-10题二，使用位运算来记录状态，但是由于数字未限制范围，可能是Integer.MAX_VALUE，所以不能用这种做法。可以使用第一行和第一列来记录状态，思路如下：
   >
   > 1. 使用两个变量记录第一行和第一列是否有0.
   > 2. 遍历matrix[1~m-1\][1~n-1\]，若matrix[i][j\]为0，则matrix[i\][0\]=matrix[0\][j\]=0.
   > 3. 若matrix[i\][0\]为0，将该行全置0；若matrix[i\][0\]为0，将该列全置0.
   > 4. 根据初始的两个变量决定是否将第一行和第一列置0.

   ```java
   class Solution {
   
       public void setZeroes(int[][] matrix) {
           int m = matrix.length;
           if(m==0) return;
           int n = matrix[0].length;
           boolean hasZeroCol0 = false, hasZeroRow0 = false;
           for(int i = 0; i < m; i++) {
               if(matrix[i][0] == 0) hasZeroCol0 = true;
           }
           for(int j = 0; j < n; j++) {
               if(matrix[0][j] == 0) hasZeroRow0 = true;
           }
           
           for(int i = 1; i < m; i++) {
               for(int j = 1; j < n;j++) {
                   if(matrix[i][j]==0) matrix[i][0]=matrix[0][j]=0;
               }
           }
           
           for(int i = 1; i < m; i++) {
               if(matrix[i][0] == 0){
                   for(int j = 1; j < n;j++) matrix[i][j]=0;
               }
           }
           
           for(int j = 1; j < n; j++) {
               if(matrix[0][j] == 0){
                   for(int i = 1; i < m;i++) matrix[i][j]=0;
               }
           }
           
           if(hasZeroRow0){
               for(int j = 0; j < n; j++) matrix[0][j]=0;
           }
           
           if(hasZeroCol0){
               for(int i = 0; i < m; i++) matrix[i][0]=0;
           }
       }
   }
   ```
