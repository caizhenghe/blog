# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          List<Integer> output = new ArrayList<Integer>();
          public List<Integer> inorderTraversal(TreeNode root) {
              if(root == null) {
                  return output;
              }
              inorderTraversal(root.left);
              output.add(root.val);
              inorderTraversal(root.right);
              return output;
          }
      }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```


## 2018-12-04

1. （Star）输入一个数组，输出该数组的所有序列List<List\<Integer\>>。#46

   > 基本思路：
   >
   > 1. n个数的数组有n\*(n-1)\*...\*2\*1种组合。
   > 2. 当a添加至包含n-1个数的数组时，将a与数组中的每个数替换，都会有(n-1)\*(n-1)\*…1种组合，最终形成第一点所说的组合数目。
   >
   > Tips：List的addAll和clone都是浅拷贝，每个元素都指向同一块内存地址。



   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> results = new ArrayList<List<Integer>>();
           
           permuteRecursion(results, nums, 0, nums.length - 1);
           
           return results;
       }
       
       public void permuteRecursion(List<List<Integer>> results, int[] nums, int start, int end) {
           if(start == end) {
               List<Integer> result = new ArrayList<Integer>();
               for (int num : nums) {
                   result.add(num);
               }
               results.add(result);
           } else {
               for(int i = start; i <= end; i++) {
                   nums = swap(nums, start, i);
                   permuteRecursion(results, nums, start + 1, end);
                   nums = swap(nums, start, i);
               }
           }
       }
       
       public int[] swap(int[] nums, int first, int second) {
           int c = nums[first];
           nums[first] = nums[second];
           nums[second] = c;
           
           return nums;
       }
   }
   ```

2. 输入n，输出所有可能的括号排序List\<String\>，要求左右括号一一对应。#22

   > Tips：String、StringBuffer、StringBuilder的区别：（TODO）
   >
   > 修改String的值本质上是给它分配了一块新的内存地址；StringBuffer的append方法则是在原来的内存地址上修改值。
   >
   > 基本思路：
   >
   > 1. 剩余左括号的数量小于等于剩余右括号的数量。
   > 2. 使用递归的思路，当剩余左括号为0时，append所有剩余右括号；当剩余左括号等于右括号时，append左括号并递归；其余情况分别append左括号和右括号并递归（append右括号时需要往List中添加新的字符串）。



   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<StringBuffer> tmp = new ArrayList<StringBuffer>();
           StringBuffer sb = new StringBuffer("");
           tmp.add(sb);
           recursion(tmp, sb, n, n);
   
           List<String> result = new ArrayList<String>();
           for(StringBuffer item : tmp) {
               result.add(item.toString());
           }
           return result;
       }
   
       public void recursion(List<StringBuffer> list, StringBuffer s, int left, int right) {
           if (left == 0) {
               while(right > 0) {
                   s.append(")");
                   right--;
               }
           }
           else if(left == right) {
               s.append("(");
               recursion(list, s, left - 1, right);
           } else {
               StringBuffer tmp = new StringBuffer(s.toString());
               s.append("(");
               recursion(list, s, left - 1, right);
               list.add(tmp.append(")"));
               recursion(list, tmp, left, right - 1);
           }
       }
   }
   ```


## 2018-12-05

1. 输入一个无重复元素的数组（distinct integers），输出所有的子集List<List\<Integer\>>，要求子集不能有重复。#78

   > 基本思路：找规律，假设已经得到nums[0～n-1]的子集Subset1，深拷贝一份子集Subset2，再将nums[n]加入Subset2的每个元素中即可。



   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> results = new ArrayList<>();
           results.add(new ArrayList<Integer>());
           if(nums == null || nums.length == 0)
               return results;
           int end = 0;
           while(end < nums.length) {
               int originSize = results.size();
               results.addAll(deepClone(results));
               for(int i = originSize; i < results.size(); i++) {
                   results.get(i).add(nums[end]);
               };
               end++;
           }
           return results;
       }
       
       public List<List<Integer>> deepClone(List<List<Integer>> reses) {
           List<List<Integer>> results = new ArrayList<>();
           for(List<Integer> res : reses) {
               List<Integer> result = new ArrayList<>();
               for(Integer i : res) {
                   result.add(i);
               }
               results.add(result);
           }
           return results;
       }
   }
   ```

2. 输入BST的根节点和k，返回BST中第k小的元素。#230

   > Tips：
   >
   > 1. BST（二叉搜索树）的概念：左子节点<根节点<右子节点。
   > 2. B树、B+树、B-树、B*树的概念。（TODO）
   >
   > 基本思路：
   >
   > BST中，中序遍历BST，第k个节点就是Kth smallest element。



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public int kthSmallest(TreeNode root, int k) {
           List<Integer> result = new ArrayList<Integer>();
           recursion(root, result, k);
           return result.get(k - 1);
       }
       
       public void recursion(TreeNode root, List<Integer> list, int k) {
           if(root == null || list.size() >= k)
               return;
           recursion(root.left, list, k);
           list.add(root.val);
           recursion(root.right, list, k);
       }
   }
   ```


## 2018-12-06

1. 输入两个链表，输出一个链表，要求每个元素是输入链表对应位置元素之和，包含进位。#2

   ```java
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           ListNode node = new ListNode(0);
           ListNode iterator = node;
           int add = 0;
           while (l1 != null || l2 != null || add > 0) {
               int x = 0, y = 0, all = 0;
               if (l1 != null) {
                   x = l1.val;
                   l1 = l1.next;
               }
   
               if (l2 != null) {
                   y = l2.val;
                   l2 = l2.next;
               }
   
               all = x + y + add;
               add = all / 10;
               iterator.val = all % 10;
               if (l1 != null || l2 != null || add > 0)
                   iterator.next = new ListNode(0);
               iterator = iterator.next;
           }
           return node;
       }
   }
   ```

2. （Star）输入一个字符串，输出其中不重复的连续子字符串的最大长度。#3

   > 基本思路：
   >
   > 1. 使用Map，其中key表示字符，value表示字符出现的顺序索引，记录一个不重复子串的初始索引。遍历字符串，若字符索引大于等于初始索引，说明该字符已经存在，更新最大长度和当前子串长度，更新初始索引，并对该字符记录新的索引；若该字符不存在， ，并对该字符记录索引。
   > 2. 若使用Hash数组代替Map，使用数组下标代替key，需要开辟能够包含所有ASC字符的数组（ASC表长度为177）。
   > 3. Discuss其余思路（TODO）



   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           if(s == null || s.equals(""))
               return 0;
           int[] hash = new int[178];
           int max = 0, length = 0, validIndex = 100;
           for(int i = 0; i < s.length(); i++) {
               char c = s.charAt(i);
               int index = hash[c - '\0'];
               if(index >= validIndex) {
                   max = Math.max(max, length);
                   length = length - (index - validIndex);
                   validIndex = index + 1;
               } else {
                   length++;
               }
               hash[c - '\0'] = validIndex + length - 1;
   
           }
           return Math.max(max, length);
       }
   }
   ```


## 2018-12-08

1. （Star）求有序二维矩阵中的第k小的值。#378

   > 基础知识点：
   >
   > 1. 堆排序：要求子节点比父节点大/小，根节点最大/小。每次插入元素后堆重新排序，排序后依然满足前述特点。
   > 2. PriorityQueue：有序队列，内部使用堆排序的方式排列数据，有以下特点：
   >    - 不满足FIFO（先入先出，队尾插入队首移除）。
   >    - 直接打印队列时数据是无序的，只能保证队首元素最大/最小。遍历出栈的数据是有序的。
   >    - PriorityQueue有两种排序方式：
   >      - 自然排序：按元素的大小排序，数据以升序的方式出列。
   >      - 定制排序：复写Comparator\<T\>接口，元素的compareTo方法返回负数时，堆重新排序，将该元素放到队首；返回正数时，直接将元素插到队尾，不重新排序。
   >    - poll/offer和remove/add的区别：
   >      - 当队列为空时，poll直接返回null，remove抛出异常。
   >      - 当队列为满时，offer直接返回false，而add返回uncheck异常。
   >    - peek和element的区别：两者均是搜索队首元素，但不将其出列。当队列为空时，peek返回null，element抛出异常。
   >
   >
   >
   > 基本思路：
   >
   > 1. 每个元素需要记录自身的位置（x,y），定义PriorityQueue，要求队首元素最小。
   > 2. 将二维矩阵的第一行元素入列。
   > 3. 遍历k-1次，每次遍历时出列一个元素（x,y），并将（x，y+1）元素入列（当y到达最后一行时，直接出列下一个元素）。
   > 4. 出列k-1个元素后，下个元素就是Kth smallest。



   ```java
   class Solution {
           class Tuple implements Comparable<Tuple> {
               int x;
               int y;
               int val;
   
               public Tuple(int x, int y, int val) {
                   this.x = x;
                   this.y = y;
                   this.val = val;
               }
   
   
               @Override
               public int compareTo(Tuple o) {
                   return this.val - o.val;
               }
           }
   
           public int kthSmallest(int[][] matrix, int k) {
               int n = matrix.length;
               PriorityQueue<Tuple> queue = new PriorityQueue<>();
               for (int i = 0; i < n; i++) {
                   queue.offer(new Tuple(i, 0, matrix[i][0]));
               }
   
               for (int i = 0; i < k - 1; i++) {
                   Tuple e = queue.poll();
                   if (e.y == n - 1) continue;
                   queue.offer(new Tuple(e.x, e.y + 1, matrix[e.x][e.y + 1]));
               }
               return queue.poll().val;
           }
       }
   ```

2. 将一个链表重新排序，要求奇数下标的节点相连，偶数下标的节点相连，最后将偶数节点链表接在奇数节点链表后面。要求空间复杂度为O(1)，时间复杂度为O(n)。#328

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode oddEvenList(ListNode head) {
           if(head == null)
               return null;
           
           ListNode evenHead = head.next;
           ListNode lastOddCache = null;
           ListNode it = head;
           int nodeCount = 1;
           while(it.next != null) {
               ListNode tmp = it.next;
               it.next = it.next.next;
               if(nodeCount % 2 != 0) {
                   lastOddCache = it;
               }
               it = tmp;
               nodeCount++;
           }
           
           if(nodeCount % 2 == 0) {
               lastOddCache.next = evenHead;
           } else {
               it.next = evenHead;
           }
           return head;
       }
   }
   ```

3. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字，要求不能修改输入的数组，空间复杂度为O(1)，时间复杂度小于O(n^2)。#287

   > 基本思路：
   >
   > 该题与12-03题1雷同，难点在于不能修改输入的数组且空间复杂度为O(1)。

