# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       List<Integer> output = new ArrayList<Integer>();
       public List<Integer> inorderTraversal(TreeNode root) {
           if(root == null) {
               return output;
           }
           inorderTraversal(root.left);
           output.add(root.val);
           inorderTraversal(root.right);
           return output;
       }
   }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```

7. 