# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          List<Integer> output = new ArrayList<Integer>();
          public List<Integer> inorderTraversal(TreeNode root) {
              if(root == null) {
                  return output;
              }
              inorderTraversal(root.left);
              output.add(root.val);
              inorderTraversal(root.right);
              return output;
          }
      }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```


## 2018-12-04

1. （Star）输入一个数组，输出该数组的所有序列List<List\<Integer\>>。#46

   > 基本思路：
   >
   > 1. n个数的数组有n\*(n-1)\*...\*2\*1种组合。
   > 2. 当a添加至包含n-1个数的数组时，将a与数组中的每个数替换，都会有(n-1)\*(n-2)\*…1种组合，最终形成第一点所说的组合数目。
   >
   > Tips：List的addAll和clone都是浅拷贝，每个元素都指向同一块内存地址。



   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> results = new ArrayList<List<Integer>>();
           
           permuteRecursion(results, nums, 0, nums.length - 1);
           
           return results;
       }
       
       public void permuteRecursion(List<List<Integer>> results, int[] nums, int start, int end) {
           if(start == end) {
               List<Integer> result = new ArrayList<Integer>();
               for (int num : nums) {
                   result.add(num);
               }
               results.add(result);
           } else {
               for(int i = start; i <= end; i++) {
                   nums = swap(nums, start, i);
                   permuteRecursion(results, nums, start + 1, end);
                   nums = swap(nums, start, i);
               }
           }
       }
       
       public int[] swap(int[] nums, int first, int second) {
           int c = nums[first];
           nums[first] = nums[second];
           nums[second] = c;
           
           return nums;
       }
   }
   ```

2. （Good）输入n，输出所有可能的括号排序List\<String\>，要求左右括号一一对应。#22

   > Tips：String、StringBuffer、StringBuilder的区别：（TODO）
   >
   > 修改String的值本质上是给它分配了一块新的内存地址；StringBuffer的append方法则是在原来的内存地址上修改值。
   >
   > 基本思路：
   >
   > 1. 剩余左括号的数量小于等于剩余右括号的数量。
   > 2. 使用递归的思路，当剩余左括号为0时，append所有剩余右括号；当剩余左括号等于右括号时，append左括号并递归；其余情况分别append左括号和右括号并递归（append右括号时需要往List中添加新的字符串）。



   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<StringBuffer> tmp = new ArrayList<StringBuffer>();
           StringBuffer sb = new StringBuffer("");
           tmp.add(sb);
           recursion(tmp, sb, n, n);
   
           List<String> result = new ArrayList<String>();
           for(StringBuffer item : tmp) {
               result.add(item.toString());
           }
           return result;
       }
   
       public void recursion(List<StringBuffer> list, StringBuffer s, int left, int right) {
           if (left == 0) {
               while(right > 0) {
                   s.append(")");
                   right--;
               }
           }
           else if(left == right) {
               s.append("(");
               recursion(list, s, left - 1, right);
           } else {
               StringBuffer tmp = new StringBuffer(s.toString());
               s.append("(");
               recursion(list, s, left - 1, right);
               list.add(tmp.append(")"));
               recursion(list, tmp, left, right - 1);
           }
       }
   }
   ```


## 2018-12-05

1. 输入一个无重复元素的数组（distinct integers），输出所有的子集List<List\<Integer\>>，要求子集不能有重复。#78

   > 基本思路：找规律，假设已经得到nums[0～n-1]的子集Subset1，深拷贝一份子集Subset2，再将nums[n]加入Subset2的每个元素中即可。



   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> results = new ArrayList<>();
           results.add(new ArrayList<Integer>());
           if(nums == null || nums.length == 0)
               return results;
           int end = 0;
           while(end < nums.length) {
               int originSize = results.size();
               results.addAll(deepClone(results));
               for(int i = originSize; i < results.size(); i++) {
                   results.get(i).add(nums[end]);
               };
               end++;
           }
           return results;
       }
       
       public List<List<Integer>> deepClone(List<List<Integer>> reses) {
           List<List<Integer>> results = new ArrayList<>();
           for(List<Integer> res : reses) {
               List<Integer> result = new ArrayList<>();
               for(Integer i : res) {
                   result.add(i);
               }
               results.add(result);
           }
           return results;
       }
   }
   ```

2. （Good）输入BST的根节点和k，返回BST中第k小的元素。#230

   > Tips：
   >
   > 1. BST（二叉搜索树）的概念：左子节点<根节点<右子节点。
   > 2. B树、B+树、B-树、B*树的概念。（TODO）
   >
   > 基本思路：
   >
   > BST中，中序遍历BST，第k个节点就是Kth smallest element。



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public int kthSmallest(TreeNode root, int k) {
           List<Integer> result = new ArrayList<Integer>();
           recursion(root, result, k);
           return result.get(k - 1);
       }
       
       public void recursion(TreeNode root, List<Integer> list, int k) {
           if(root == null || list.size() >= k)
               return;
           recursion(root.left, list, k);
           list.add(root.val);
           recursion(root.right, list, k);
       }
   }
   ```


## 2018-12-06

1. 输入两个链表，输出一个链表，要求每个元素是输入链表对应位置元素之和，包含进位。#2

   ```java
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           ListNode node = new ListNode(0);
           ListNode iterator = node;
           int add = 0;
           while (l1 != null || l2 != null || add > 0) {
               int x = 0, y = 0, all = 0;
               if (l1 != null) {
                   x = l1.val;
                   l1 = l1.next;
               }
   
               if (l2 != null) {
                   y = l2.val;
                   l2 = l2.next;
               }
   
               all = x + y + add;
               add = all / 10;
               iterator.val = all % 10;
               if (l1 != null || l2 != null || add > 0)
                   iterator.next = new ListNode(0);
               iterator = iterator.next;
           }
           return node;
       }
   }
   ```

2. （Good）输入一个字符串，输出其中不重复的连续子字符串的最大长度。#3

   > 基本思路：
   >
   > 1. 使用Map，其中key表示字符，value表示字符出现的顺序索引，记录一个不重复子串的初始索引。遍历字符串，若字符索引大于等于初始索引，说明该字符已经存在，更新最大长度和当前子串长度，更新初始索引，并对该字符记录新的索引；若该字符不存在， ，并对该字符记录索引。
   > 2. 若使用Hash数组代替Map，使用数组下标代替key，需要开辟能够包含所有ASC字符的数组（ASC表长度为177）。
   > 3. Discuss其余思路（TODO）



   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           if(s == null || s.equals(""))
               return 0;
           int[] hash = new int[178];
           int max = 0, length = 0, validIndex = 100;
           for(int i = 0; i < s.length(); i++) {
               char c = s.charAt(i);
               int index = hash[c - '\0'];
               if(index >= validIndex) {
                   max = Math.max(max, length);
                   length = length - (index - validIndex);
                   validIndex = index + 1;
               } else {
                   length++;
               }
               hash[c - '\0'] = validIndex + length - 1;
   
           }
           return Math.max(max, length);
       }
   }
   ```


## 2018-12-08

1. （Star）求有序二维矩阵中的第k小的值。#378

   > 基础知识点：
   >
   > 1. 堆排序：要求子节点比父节点大/小，根节点最大/小。每次插入元素后堆重新排序，排序后依然满足前述特点。
   > 2. PriorityQueue：有序队列，内部使用堆排序的方式排列数据，有以下特点：
   >    - 不满足FIFO（先入先出，队尾插入队首移除）。
   >    - 直接打印队列时数据是无序的，只能保证队首元素最大/最小。遍历出栈的数据是有序的。
   >    - PriorityQueue有两种排序方式：
   >      - 自然排序：按元素的大小排序，数据以升序的方式出列。
   >      - 定制排序：复写Comparator\<T\>接口，元素的compareTo方法返回负数时，堆重新排序，将该元素放到队首；返回正数时，直接将元素插到队尾，不重新排序。
   >    - poll/offer和remove/add的区别：
   >      - 当队列为空时，poll直接返回null，remove抛出异常。
   >      - 当队列为满时，offer直接返回false，而add返回uncheck异常。
   >    - peek和element的区别：两者均是搜索队首元素，但不将其出列。当队列为空时，peek返回null，element抛出异常。
   >
   >
   >
   > 基本思路：
   >
   > 1. 每个元素需要记录自身的位置（x,y），借助PriorityQueue进行排序，要求队首元素最小。
   > 2. 将二维矩阵的第一行元素入列。
   > 3. 遍历k-1次，每次遍历时出列一个元素（x,y），并将（x，y+1）元素入列（当y到达最后一行时，直接出列下一个元素）。
   > 4. 出列k-1个元素后，下个元素就是Kth smallest。



   ```java
   class Solution {
           class Tuple implements Comparable<Tuple> {
               int x;
               int y;
               int val;
   
               public Tuple(int x, int y, int val) {
                   this.x = x;
                   this.y = y;
                   this.val = val;
               }
   
   
               @Override
               public int compareTo(Tuple o) {
                   return this.val - o.val;
               }
           }
   
           public int kthSmallest(int[][] matrix, int k) {
               int n = matrix.length;
               PriorityQueue<Tuple> queue = new PriorityQueue<>();
               for (int i = 0; i < n; i++) {
                   queue.offer(new Tuple(i, 0, matrix[i][0]));
               }
   
               for (int i = 0; i < k - 1; i++) {
                   Tuple e = queue.poll();
                   if (e.y == n - 1) continue;
                   queue.offer(new Tuple(e.x, e.y + 1, matrix[e.x][e.y + 1]));
               }
               return queue.poll().val;
           }
       }
   ```

2. 将一个链表重新排序，要求奇数下标的节点相连，偶数下标的节点相连，最后将偶数节点链表接在奇数节点链表后面。要求空间复杂度为O(1)，时间复杂度为O(n)。#328

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode oddEvenList(ListNode head) {
           if(head == null)
               return null;
           
           ListNode evenHead = head.next;
           ListNode lastOddCache = null;
           ListNode it = head;
           int nodeCount = 1;
           while(it.next != null) {
               ListNode tmp = it.next;
               it.next = it.next.next;
               if(nodeCount % 2 != 0) {
                   lastOddCache = it;
               }
               it = tmp;
               nodeCount++;
           }
           
           if(nodeCount % 2 == 0) {
               lastOddCache.next = evenHead;
           } else {
               it.next = evenHead;
           }
           return head;
       }
   }
   ```

3. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字，要求不能修改输入的数组，空间复杂度为O(1)，时间复杂度小于O(n^2)。#287

   > 基本思路：
   >
   > 该题与12-03题1雷同，难点在于不能修改输入的数组且空间复杂度为O(1)。

   ```java
   // TODO
   ```

## 2018-12-09

1. 输入一个二叉树，输出一个二维数组（List<List\<Integer\>>），要求数组的每一行都对应树的每一层级。#102

   > 基本思路：
   >
   > - 本题考查二叉树的层序遍历，可以借助队列（LinkedList）来实现树的层序遍历。
   > - 给节点增加level属性，表示节点在树中的层级，当第一次碰到下一个层级的节点时，往二维数组中增加一行。

   ```java
   class Solution {
       class TreeNodeWrapper {
           TreeNode node;
           int level;
           public TreeNodeWrapper (TreeNode node, int level) {
               this.node = node;
               this.level = level;
           }
       }
       public List<List<Integer>> levelOrder(TreeNode root) {
           Queue<TreeNodeWrapper> queue = new LinkedList<>();
           queue.offer(new TreeNodeWrapper(root, 1));
           List<List<Integer>> results = new ArrayList<>();
           int originLevel = 0;
           if(root == null)
               return results;
           while(!queue.isEmpty()) {
               int newLevel = 0;
               TreeNodeWrapper item = queue.poll();
               if(originLevel < item.level) {
                   List<Integer> result = new ArrayList<>();
                   results.add(result);
                   originLevel = item.level;
               }
               results.get(results.size() - 1).add(item.node.val);
               if(item.node.left != null) {
                   queue.offer(new TreeNodeWrapper(item.node.left, item.level + 1));
               }
               if(item.node.right != null) {
                   queue.offer(new TreeNodeWrapper(item.node.right, item.level + 1));
               }
           }
           return results;
       }
   }
   ```

2. （Star）在一个m*n的表格中，计算从 (1, 1) 到 (m, n) 的路径的数量。#62

   > 使用递归的方法：path(m, n) = path(m - 1, n) + path(m, n - 1) ；path(m, 1) = 1；path(1, n) = 1。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           if(m == 1 || n == 1) {
               return 1;
           }
           return uniquePaths(m, n - 1) + uniquePaths(m - 1, n);
       }
   }
   ```

   > 在LeetCode上提交后会发现：单纯使用递归会报Time Limit Exceed错误（超出时间限制），因为递归会重复进行同一个网点的计算（比如递归计算 path(3, 3) 时，无论 (2, 3) 还是 (3, 2)，都会重复计算 path(2, 2) ），并且递归会保留每一个函数的上下文对象，空间复杂度也很高。
   >
   > 优化方案是记录每一个网点的计算结果，在递归时进行判断，若该网点已经计算，直接返回值，否则再进行下一轮递归，这种办法叫**自顶向下的备忘录法**。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           return reversion(m, n, paths);
       }
       
       public int reversion(int m, int n, int[][] array) {
           if(array[m - 1][n - 1] != 0)
               return array[m - 1][n - 1];
           if(m == 1 || n == 1) {
               array[m - 1][n - 1] = 1;
           } else {
               array[m - 1][n - 1] = reversion(m, n -1, array) + reversion(m - 1, n, array);
           }
           return array[m - 1][n - 1];
       }
   }
   ```

   > 增加了备忘录后，计算Path(6, 6) 总归还是要计算到 Path(1, n) 和 Path(m, 1)的，为何不先从路径少的网点算起呢？
   >
   > DP的核心在于：先计算子问题，再由子问题计算父问题 。这就是**自底向上的动态规划**。在LeetCode上运行后会发现，动态规划（0ms，defeat 100%）比备忘录法（1ms，defeat 7%）的效率更高。

   ```java
   class Solution {
       public int uniquePaths(int m, int n) {
           int[][] paths = new int[m][n];
           for(int i = 0; i < m; i++) {
               paths[i][0] = 1;
           }
           
           for(int j = 0; j < n; j++) {
               paths[0][j] = 1;
           }
           for(int i = 1; i < m; i++) {
               for(int j = 1; j < n; j++) {
                   paths[i][j] = paths[i - 1][j] + paths[i][j -1];
               }
           }
           return paths[m - 1][n - 1];
       }
   }
   ```

3. 输入一个n*n的二维矩阵，将该矩阵顺时针旋转90度后输出。要求空间复杂度为O(1)。#48

   > 这是一个脑洞题，思路如下：
   >
   > 1. 将矩阵沿对角线对称翻转：transpose: swap(matrix\[i\][j], matrix\[j\][i])
   > 2. 将矩阵沿居中的y轴翻转：flip horizontally: swap(matrix\[i\][j], matrix\[i\][matrix.length - j - 1])

   ```java
   class Solution {
       public void rotate(int[][] matrix) {
           // 1. traspose: swap(matrix[i][j], matrix[j][i])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = i + 1; j < matrix.length; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[j][i];
                   matrix[j][i] = tmp;
               }
           }
           
           // 2. flip horizontally: swap(matrix[i][j], matrix[i][matrix.length - j - 1])
           for (int i = 0; i < matrix.length; i++) {
               for (int j = 0; j < matrix.length / 2; j++) {
                   int tmp = matrix[i][j];
                   matrix[i][j] = matrix[i][matrix.length - j - 1];
                   matrix[i][matrix.length - j - 1] = tmp;
               }
           }
       }
   }
   ```


## 2018-12-10

1. 输入一个包含不同顺序短语的字符串数组（anagrams），要求将相同字符，但不同顺序的短语归成一组，输出List<List\<String>>。#49

   > 基本思路：
   >
   > 1. 遍历每个字符串，将其转换成char数组，对char数组排序（Arrays.sort），再转换成排序后的字符串。
   > 2. 查看临时缓存Map<String, List\<String>>中是否包含对应的key，并将字符串插入Map对应key的List\<String>中。
   > 3. 最后输出List<List\<String>>。（Map.values）

   ```java
   class Solution {
       public List<List<String>> groupAnagrams(String[] strs) {
           Map<String, List<String>> map = new HashMap<>();
           for(String s : strs) {
               char[] chars = s.toCharArray();
               Arrays.sort(chars);
               String ss = String.valueOf(chars);
               if(map.getOrDefault(ss, null) == null) map.put(ss, new ArrayList<String>());
               map.get(ss).add(s);
           }
           return new ArrayList<List<String>>(map.values());
       }
   }
   ```

2. Game of life #289. 输入一个二维数组，每个元素为0或1，代表细胞的生死。经过一个周期后，计算这些细胞的生死。细胞存活的规律如下：

   1. 若是死细胞，当周边8个细胞中有3个活细胞时，该细胞复活，否则继续死亡。
   2. 若是活细胞，当周边8个细胞中有2～3个活细胞时，该细胞继续存活，否则死亡。
   3. 要求solve it in-place，即不能开辟新的二维数组存储状态。

   > 基本思路：这是一道脑洞题，难点主要在in-place上。因为所有细胞都是同时转变，所以转变的规律是依靠四周细胞的旧状态来决定的。这就要求将新旧状态全都存储在一个int类型的数据中，规则如下：
   >
   > [2nd bit, 1st bit] -> [new state, old state]
   >
   > 然后遍历数组，统计每个细胞周边细胞旧状态下的存活数，计算出该细胞的新状态，并更新到数组中。



   ```java
   // clean code!
   class Solution {
       public void gameOfLife(int[][] board) {
           int m = board.length, n = board[0].length;
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   int lives = liveNum(board, i, j, m, n);
                   if(board[i][j] == 0 && lives == 3) {
                       board[i][j] = 2;
                   }
                   
                   if(board[i][j] == 1 && lives >= 2 && lives <= 3) {
                       board[i][j] = 3;
                   }
               }
           }
           
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   board[i][j] >>= 1;
               }
           }
       }
       
       private int liveNum(int[][] board, int i, int j, int m, int n) {
           int lives = 0;
           for(int x = Math.max(0, i - 1); x <= Math.min(i + 1, m - 1); x++) {
               for(int y = Math.max(0, j - 1); y <= Math.min(j + 1, n - 1); y++) {
                   lives += board[x][y] & 1;
               }
           }
           lives -= board[i][j] & 1;
           return lives;
       }
   }
   ```


## 2018-12-11

1. 设计一个数据集合，实现数据的增删改查以及获取随机数功能。#380

   > 基本思路：利用HashSet来实现增删改查，利用Math.random来获取随机数据。
   >
   > TODO：
   >
   > 1. 了解HashSet和HashMap的内部实现。
   > 2. 如果要支持多线程，该如何优化该数据集（ConcurrentHashMap）。
   > 3. better discussing。



   ```java
   class RandomizedSet {
       Set<Integer> data;
   
       /**
        * Initialize your data structure here.
        */
       public RandomizedSet() {
           data = new HashSet<>();
       }
   
       /**
        * Inserts a value to the set. Returns true if the set did not already contain the specified element.
        */
       public boolean insert(int val) {
           if (data.contains(val))
               return false;
           else
               data.add(val);
           return true;
       }
   
       /**
        * Removes a value from the set. Returns true if the set contained the specified element.
        */
       public boolean remove(int val) {
           if (!data.contains(val))
               return false;
           else
               data.remove(val);
           return true;
       }
   
       /**
        * Get a random element from the set.
        */
       public int getRandom() {
           double random = Math.random();
           Integer[] array = new Integer[data.size()];
           array = data.toArray(array);
           return array[(int) (data.size() * random)];
       }
   }
   ```

2. 给定n个非负整数a1，a2，...，an，每个整数代表坐标（i，ai）处的一个点。 绘制n条垂直线，使得线i的两个端点处于（i，ai）和（i，0）处。 找到两条线，它们与x轴一起形成一个容器，以使容器包含最多的水。#11

   > 基本思路：
   >
   > 1. 最简单的做法是双重遍历，时间复杂度为O(nlogn)，分别计算每个容器的面积并返回最大面积。
   > 2. 利用贪婪算法，只计算局部最优解，不可回溯，在上一步的局部最优解基础上进行下一步计算，可能会错过全局最优解，但是可以有效减少判断次数。



   ```java
   // normal solution
   class Solution {
       public int maxArea(int[] height) {
           int maxS = 0;
           for(int i = 0; i < height.length; i++) {
               for(int j = i + 1; j < height.length; j++) {
                   int s = Math.min(height[i], height[j]) * (j - i);
                   maxS = Math.max(s, maxS);
               }
           }
           return maxS;
       }
   }
   
   // greedy solution，move left/right when val(left/right) is smaller in once foreach.
   class Solution {
       public int maxArea(int[] height) {
           int i = 0, j = height.length - 1, max = 0;
           while(j >= i) {
               int s = Math.min(height[i], height[j]) * (j - i);
               max = Math.max(s, max);
               if(height[i] > height[j])
                   j--;
               else
                   i++;
           }
           return max;
       }
   }
   ```


## 2018-12-13

1. Jump game. 给定一个数组N，从第i个元素最多可以跳到第N[i] + i个元素，以此类推，输出结果：是否可以跳到数组的尾部。#55. Greedy

   > 基本思路：本题本质上是考察是否可以避开数组中值为0的元素，下面给出两种解法。



   ```java
   // 1. 记录可以跳的最远距离
   class Solution {
       public boolean canJump(int[] nums) {
           int max = 0;
           for(int i = 1; i < nums.length; i++) {
               // 前一个元素值为0且前置位元素跳的最远距离都到达不了当前元素时返回false。
               if(nums[i - 1] == 0 && i > nums[max] + max) {
                   return false;
               }
               // 更新跳的最远的元素下标。
               max = i + nums[i] > max + nums[max] ? i : max;
           }
           return true;
       }
   }
   
   // 2. 遍历查找是否有规避值为0的元素的方法。
   public class Solution {
       public boolean canJump(int[] nums) {
           if (nums.length < 2)
               return true;
           search : for (int i = nums.length - 2; i >= 0; i--) {
               if (nums[i] == 0) {
                   // 从值为0的元素往前找，若所有元素均跳不到i则返回false，不然直接从第一层循环开始下一次遍历
                   for (int j = i - 1; j >= 0; j--) {
                       if (nums[j] > i - j) {
                           i = j;
                           continue search;
                       }
                   }
                   return false;
               }
           }
           return true;
       }
   }
   ```

2. 假设"()"是一对有效括号，现给定一组乱序排列的括号字符串，求添加几个圆括号可以使该字符串内部全部变成有效括号。#921. Greedy

   > 基本思路：本题不仅仅是计算左括号和右括号的个数，还要注意括号的顺序，比如")))((("返回6，而"((()))"则返回0。



   ```java
   class Solution {
       public int minAddToMakeValid(String S) {
           if(S == null || S.length() == 0)
               return 0;
           int left = 0, right = 0, count = 0;
           char[] array = S.toCharArray();
           for(char c : array) {
               if(c == '(') {
                   left++;
                   count++;
               } else {
                   right++;
                   if(right > left) {
                       // 当右括号比左括号多时，count++。由于这些右括号是无效括号，不计入right，避免影响后续计算：例如")()"。
                       count++;
                       right--;
                   } else {
                       count--;
                   }
               }
           }
           return Math.abs(count);
       }
   }
   ```

3. 输入一个9*9的数独数组，判断该数组是否合法（合法数独的行、列、9宫格中的数字均不重复）。#36

   > 基础思路：
   >
   > 1. 本题主要考察如何同时遍历数组的行、列和九宫格。
   > 2. 可以采用三个Set分别存储一行、一列、一个九宫格的数据，Set.add若返回true则表示已存在该数据。

   ```java
   class Solution {
       public boolean isValidSudoku(char[][] board) {
           for(int i = 0; i < 9; i++) {
               Set<Character> row = new HashSet<Character>();
               Set<Character> column = new HashSet<Character>();
               Set<Character> cube = new HashSet<Character>();
               for(int j = 0; j < 9; j++) {
                   if(board[i][j] != '.' && !row.add(board[i][j])) {
                       return false;
                   }
                   if(board[j][i] != '.' && !column.add(board[j][i])) {
                       return false;
                   }
                   // rowIndex, columnIndex表示每个九宫格首元素的(x,y)坐标
                   int rowIndex = i/3*3;
                   int columnIndex = i%3*3;
                   if(board[rowIndex+j/3][columnIndex+j%3]!='.' && !cube.add(board[rowIndex+j/3][columnIndex+j%3])) {
                       return false;
                   }
               }
           }
           return true;
       }
   }
   ```

## 2018-12-14

1. 输入包含0,1,2的乱序数组，输出按照1->0->2排序的有序数组。要求不能使用Arrays.sort方法，空间复杂度为O（1）。不建议使用如下做法：遍历数组，分别记录数组中0,1,2的个数，再填充至数组中。#75

   > 基本思路：本题本质上就是将1放到数组的前面，2放到数组的后面，0就留在数组的中间。

   ```java
   class Solution {
       public void sortColors(int[] nums) {
           int one = 0, two = nums.length - 1;
           // 为了减少遍历次数，可以将i<nums.length改成i<=two
           for(int i = 0; i < nums.length; i++) {
               // 若扫描到2，则将i和two上的元素互换位置并执行two--，使用while是因为换到i上的元素值可能依然是2.
               while(nums[i] == 2 && i < two) swap(i, two--, nums);
               while(nums[i] == 1 && i > one) swap(i, one++, nums);
           }
       }
   
       private void swap(int a, int b, int[] nums) {
           int tmp = nums[a];
           nums[a] = nums[b];
           nums[b] = tmp;
       }
   }
   ```

2. 找到数组中的一个峰值，要求该峰值比左右两边的值都大，第一个元素左边和最后一个元素右边的值默认为负无穷。#162

   ```java
   class Solution {
       public int findPeakElement(int[] nums) {
           int result = -1;
           if(nums == null || nums.length == 0)
               return -1;
           if(nums.length == 1)
               return 0;
           for(int i = 0; i < nums.length; i++) {
               if(nums[i] >= nums[Math.max(i-1, 0)] && nums[i] >= nums[Math.min(i+1, nums.length - 1)]) {
                   result = i;
                   break;
               }
           }
           return result;
       }
   }
   ```

3. 输入一个m*n的二维数组，每一行、每一列数字均为升序排列，求数组中是否存在给定的target。

   > 基本思路：
   >
   > 1. 与#378类似，借助PriorityQueue，从小到大依次输出数组中的元素，查询是否有与target相等的值。但是采用该种方法LeetCode会报Time Limit Exceeded错误。
   > 2. better discuss（TODO）

   ```java
   // 1. priority queue
   class Solution {
       class Tuple implements Comparable<Tuple> {
           int x;
           int y;
           int val;
   
           public Tuple(int x, int y, int val) {
               this.x = x;
               this.y = y;
               this.val = val;
           }
   
           @Override
           public int compareTo(Tuple o) {
               return this.val - o.val;
           }
       }
   
       public boolean searchMatrix(int[][] matrix, int target) {
           int row = matrix.length;
           if(matrix == null || matrix.length == 0) return false;
           int column = matrix[0].length;
           if(column == 0) return false;
           Queue<Tuple> queue = new PriorityQueue<>();
           for (int i = 0; i < column; i++) {
               queue.offer(new Tuple(0, i, matrix[0][i]));
           }
           Tuple o = new Tuple(0, 0, matrix[0][0]);
           if (o.val == target) return true;
           while (o.val < target) {
               o = queue.poll();
               if(o == null) return false;
               if (o.val == target) return true;
               if (o.x >= row - 1) continue;
               queue.offer(new Tuple(o.x + 1, o.y, matrix[o.x + 1][o.y]));
           }
           return false;
       }
   }
   
   // 2. better discuss
   public class Solution {
       public boolean searchMatrix(int[][] matrix, int target) {
           if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
               return false;
           }
           int col = matrix[0].length-1;
           int row = 0;
           while(col >= 0 && row <= matrix.length-1) {
               if(target == matrix[row][col]) {
                   return true;
               } else if(target < matrix[row][col]) {
                   col--;
               } else if(target > matrix[row][col]) {
                   row++;
               }
           }
           return false;
       }
   }
   ```



## 2018-12-17

1. （Star）输入一个无序数组，求最长递增子序列的长度（子序列可以不连续：Subsequence）。#300

   > 基本思路：本题采用DP思想，记录每个Index下的最长子序列数组dp[]。

   ```java
   class Solution {
       public int lengthOfLIS(int[] nums) {
           int max = 0;
           int[] dp = new int[nums.length];
           for(int i = 0; i < nums.length; i++) {
               // 最长子序列dp[i]初始为1，遍历nums[]中i位置之前的所有元素，若nums[j]<nums[i]，则更新最长子序列dp[i]的值。
               dp[i] = 1;
               for(int j = 0; j < i; j++) {
                   if(nums[j] < nums[i]) {
                       dp[i] = Math.max(dp[j] + 1, dp[i]);
                   }
               }
               // 记录i位置的最长子序列长度之后，更新整个数组的最长子序列长度。
               max = Math.max(dp[i], max);
           }
           return max;
       }
   }
   ```

2. （Star）输入一个数，代表正方形的面积之和（1，4，9…），求最少需要几个正方形？#279

   > 基本思路：该题依旧是DP思想，创建一个记录min square的数组dp[]，依次计算小于等于n的数的最少正方形数量。计算数n时，使用m遍历1~n，**比较dp[n]和dp[n-m*m]+1**，取最小值。

   ```java
   class Solution {
       public int numSquares(int n) {
           int[] dp = new int[n+1];
           dp[1] = 1;
           for(int i = 2; i <= n; i++) {
               for(int j = 1; j*j <= i; j++) {
                   // if dp[i] not be assigned before, just assigned by dp[i-j*j]+1
                   if(dp[i] > 0) {
                       dp[i] = Math.min(dp[i], dp[i - j*j] + 1);    
                   }else{
                       dp[i] = dp[i - j*j] + 1;
                   }
               }
           }
           return dp[n];
       }
   }
   ```

3. （Good）输入一个二叉树，蜿蜒输出二叉树中每一层的值。#103

   > 基本思路：
   >
   > 该题与12-09题一（#102）雷同，利用队列对二叉树进行层序遍历，区别在于偶数层插入List时采用List.add(val)；奇数层插入List时采用List.add(0, val)。

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       class NodeWrapper{
           TreeNode node;
           int level;
           
           NodeWrapper(TreeNode node, int depth) {
               this.node = node;
               this.level = depth;
           }
       }
       public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
           Queue<NodeWrapper> queue = new LinkedList<>();
           List<List<Integer>> result = new ArrayList<List<Integer>>();
           if(root == null)
               return result;
           queue.offer(new NodeWrapper(root, 0));
           int originLevel = -1;
           List<Integer> levelArray = null;
           while(!queue.isEmpty()) {
               NodeWrapper wrapper = queue.poll();
               
               if(wrapper.level != originLevel) {
                   levelArray = new ArrayList<Integer>();
                   result.add(levelArray);
                   originLevel = wrapper.level;
               }
               if(wrapper.level % 2 == 0) levelArray.add(wrapper.node.val);
               else levelArray.add(0, wrapper.node.val);
               
               if(wrapper.node.left != null) queue.offer(new NodeWrapper(wrapper.node.left, originLevel + 1));
               if(wrapper.node.right != null) queue.offer(new NodeWrapper(wrapper.node.right, originLevel + 1));
           }
           return result;
       }
   }
   ```

## 2018-12-18

1. 输入一个无序数组，问是否包含长度为3的递增子序列（子序列可以不连续：Subsequence）。#334

   > 基本思路：本题和12-17 题一（#300）类似，使用DP思想，当dp[i]或max大于等于3时，返回true；否则返回false。
   >
   > TODO：better discuss

   ```java
   class Solution {
       public boolean increasingTriplet(int[] nums) {
           int max = 1;
           int[] dp = new int[nums.length];
           if(nums.length < 3)
               return false;
   
           for(int i = 0; i < nums.length; i++) {
               dp[i] = 1;
               for(int j = 0; j < i; j++) {
                   if(nums[j] < nums[i]) {
                       dp[i] = Math.max(dp[j] + 1, dp[i]);
                       if(dp[i]>=3) return true;
                   }
               }
               max = Math.max(max, dp[i]);
               if(max >= 3) return true;
           }
           return false;
       }
   }
   ```

2. 输入一个数组[2,3]，输出2,3在手机九宫格中代表的字符的所有组合："ad","ae","af","bd"…… #17

   > 基本思路：本题和12-05 题一（#78）类似，每添加一个数字深拷贝n次集合（n为新增数字对应的字符数），将新增字符添加至对应的条目中。
   >
   > TODO：better discuss

   ```java
   class Solution {
       // 下标为九宫格数字，value为数字对应的letter字符串
       String letters[] = new String[]{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
       public List<String> letterCombinations(String digits) {
           List<String> output = new ArrayList<>();
           for(char digit : digits.toCharArray()) {
               append(output, digit);
           }
   
           return output;
       }
   
       private void append(List<String> output, char digit) {
           char[] letterArray = letters[digit - '2'].toCharArray();
   
           List<String> origin = deepClone(output);
   
           if(origin.size()==0) {
               // 初次添加时，直接将letter字符串中的每个字符插入列表中
               for(int i = 0; i < letterArray.length; i++) {
                   output.add(new String(Character.toString(letterArray[i])));
               }
           }else{
               // 后续添加时，深拷贝列表（假如列表size为m）n次（n为letter字符串中的字符数）。将字符0加入条目0~m-1，字符1加入条目m~2*m-1，字符n加入条目m*n~m*(n+1)-1
               for(int i = 0; i < letterArray.length - 1; i++) {
                   output.addAll(deepClone(origin));
               }
               for(int i = 0; i < output.size(); i++) {
                   String s = output.get(i);
                   output.set(i, s + Character.toString(letterArray[i / origin.size()]));
               }
           }
       }
   
       private List<String> deepClone(List<String> letters) {
           List<String> output = new ArrayList<String>();
           for(String s : letters) {
               String ss = new String(s);
               output.add(ss);
           }
           return output;
       }
   }
   ```

3. 输入一个二维数组，已知1为陆地，0为水，被水环绕的陆地为岛屿，求数组中有几个岛屿。#200

   > 基本思路：这是一道脑洞题。遍历二维数组，当遇上陆地时将与其相连的所有陆地均置位0（递归），并自增岛屿数量，最终求得的就是总岛屿数。

   ```java
   class Solution {
       public int numIslands(char[][] grid) {
           if(grid == null || grid.length == 0)
               return 0;
           int m = grid.length, n = grid[0].length;
           int result = 0;
           for(int i = 0; i < m; i++) {
               for(int j = 0; j < n; j++) {
                   if(grid[i][j] == '1') {
                       removeIsland(grid, i, j, m, n);
                       result++;
                   }
               }
           }
           return result;
       }
       private void removeIsland(char[][] grid, int i, int j, int m, int n) {
           if(i<0 || j < 0 || i >= m || j >= n || grid[i][j] != '1') return;
           grid[i][j]=0;
           removeIsland(grid, i-1, j, m, n);        
           removeIsland(grid, i+1, j, m, n);
           removeIsland(grid, i, j-1, m, n);
           removeIsland(grid, i, j+1, m, n);
       }
   }
   ```

4. （Star）输入一个字符串，输出该字符串的所有回文子串集合。例如：输入"aab",输出[["a","a","b"], ["aa","b"]]。#131

   > Tips：
   >
   > 1. 回文：一个字符串正读和倒读一致，则称为回文字符串（Palindrome）。
   >
   > 2. DFS：depth first search，深度优先遍历，例如二叉树的先序遍历、中序遍历、后序遍历。
   >
   >    BFS；breadth first search，广度优先遍历，例如二叉树的层序遍历。
   >
   > 3. String对象的substring(startIndex, endIndex)方法：endIndex表示末尾之后一位的索引。比如取String a的首元素，调用a.substring(0, 1)。
   >
   > 4. ArrayList对象的clone方法：浅拷贝。新建一个数组对象，该数组与原数组指向同一批对象。通常适用于只add/remove元素，但不修改元素内容的场景。若想要修改元素内容，且不希望影响到其他数组，则需要使用深拷贝。
   >
   > 基本思路：
   >
   > 本题使用DFS思想，使用List\<String\>cur记录当前的子串集合，当某个子串是回文时，插入cur，若回溯到最后每个子串均插入到了cur中，则将cur.clone插入结果中。每轮遍历结束，将cur末尾的子串移除，进行下一轮遍历。

   ```java
   class Solution {
       List<List<String>> results = new ArrayList<>();
       List<String> cur = new ArrayList<>();
       public List<List<String>> partition(String s) {
           dfs(s, 0);
           return results;
       }
       
       private void dfs(String s, int left) {
           for(int i = left; i < s.length(); i++) {
               String sub = s.substring(left, i+1);
               if(check(sub)) {
                   cur.add(sub);
                   dfs(s, i+1);
                   cur.remove(cur.size() - 1);
               }
           }
           if(cur.size() > 0 && left>=s.length()) {
               List<String> clone = (List<String>) ((ArrayList<String>) cur).clone();
               results.add(clone);
           }
       }
       
       private boolean check(String s) {
           return s.equals(new StringBuffer(s).reverse().toString());
       }
   }
   ```

5. 输入一个二维数组matrix，若matrix[i][j\]为0，则将该数所在的行和列均置为0，要求空间复杂度为O(1)。#73

   > 基本思路：本题乍一看类似于12-10题二，使用位运算来记录状态，但是由于数字未限制范围，可能是Integer.MAX_VALUE，所以不能用这种做法。可以使用第一行和第一列来记录状态，思路如下：
   >
   > 1. 使用两个变量记录第一行和第一列是否有0.
   > 2. 遍历matrix[1~m-1\][1~n-1\]，若matrix[i][j\]为0，则matrix[i\][0\]=matrix[0\][j\]=0.
   > 3. 若matrix[i\][0\]为0，将该行全置0；若matrix[i\][0\]为0，将该列全置0.
   > 4. 根据初始的两个变量决定是否将第一行和第一列置0.

   ```java
   class Solution {
   
       public void setZeroes(int[][] matrix) {
           int m = matrix.length;
           if(m==0) return;
           int n = matrix[0].length;
           boolean hasZeroCol0 = false, hasZeroRow0 = false;
           for(int i = 0; i < m; i++) {
               if(matrix[i][0] == 0) hasZeroCol0 = true;
           }
           for(int j = 0; j < n; j++) {
               if(matrix[0][j] == 0) hasZeroRow0 = true;
           }
           
           for(int i = 1; i < m; i++) {
               for(int j = 1; j < n;j++) {
                   if(matrix[i][j]==0) matrix[i][0]=matrix[0][j]=0;
               }
           }
           
           for(int i = 1; i < m; i++) {
               if(matrix[i][0] == 0){
                   for(int j = 1; j < n;j++) matrix[i][j]=0;
               }
           }
           
           for(int j = 1; j < n; j++) {
               if(matrix[0][j] == 0){
                   for(int i = 1; i < m;i++) matrix[i][j]=0;
               }
           }
           
           if(hasZeroRow0){
               for(int j = 0; j < n; j++) matrix[0][j]=0;
           }
           
           if(hasZeroCol0){
               for(int i = 0; i < m; i++) matrix[i][0]=0;
           }
       }
   }
   ```

## 2018-12-19

1. （Concise）输入二叉树的先序遍历和中序遍历的数组，创建一棵二叉树。#105

   > Tips：Arrays.copyOfRange(T[] origin, int from, int to)用于创建子数组，其中from表示新数组的首元素索引，**to表示新数组的末元素索引+1**。
   >
   > 基本思路：preorder[]的首元素是树的根节点，遍历查找inorder[]中首元素的位置rootIndex，rootIndex左边是左子树，右边是右子树，即preorder[1->rootIndex]是左子树，preorder[rootIndex+1->preorder.length-1]是右子树。递归继续创建左子树和右子树的根节点。

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           return recursion(preorder, inorder);
       }
       
       private TreeNode recursion(int[] preorder, int[] inorder) {
           if(preorder.length==0) return null;
           TreeNode node = new TreeNode(preorder[0]);
           int rootIndex=0;
           for(rootIndex=0;rootIndex<inorder.length;rootIndex++){
               if(inorder[rootIndex]==preorder[0]) break;
           }
           int[] leftInOrder = Arrays.copyOfRange(inorder, 0, rootIndex);
           int[] rightInOrder = Arrays.copyOfRange(inorder, rootIndex+1, inorder.length);
           int[] leftPreOrder = Arrays.copyOfRange(preorder, 1, 1+leftInOrder.length);
           int[] rightPreOrder = Arrays.copyOfRange(preorder, 1+leftInOrder.length, 1+leftInOrder.length+rightInOrder.length);
           node.left = recursion(leftPreOrder, leftInOrder);
           node.right = recursion(rightPreOrder, rightInOrder);
           return node;
    }
   }
   ```

## 2018-12-20

1. 输入一课完全二叉树，输出带有next指针的树，要求左子节点指向右子节点，右子节点指向隔壁的左子节点。#116

   ```java
   // Space O(1), Time O(n), bfs
   /**
    * Definition for binary tree with next pointer.
    * public class TreeLinkNode {
    *     int val;
    *     TreeLinkNode left, right, next;
    *     TreeLinkNode(int x) { val = x; }
    * }
    */
   public class Solution {
       public void connect(TreeLinkNode root) {
           TreeLinkNode level = root;
           while(level != null) {
               TreeLinkNode cur = level;
               while(cur != null) {
                   if(cur.left != null) cur.left.next = cur.right;
                   if(cur.right != null && cur.next!=null) cur.right.next = cur.next.left;
                   cur = cur.next;
               }
               level = level.left;
           }
       }
   }
   ```

2. （hard）输入一个数字表示课程总数，一个二维数组表示课程间的限制条件（[1,0]表示上1之前必须先上0），求该显示条件是否合理。#207

   > 基本思路：
   >
   > 1. 定义一个二维数组matrix表示限制条件，一维是先决课程，二维是依赖课程。再定义一个一维数组indegree表示依赖课程的依赖数量。将输入参数转换为这两个数组。
   > 2. 定义一个队列，将未依赖别人的课程入队列。
   > 3. 循环该队列，依次出栈未依赖别人的课程，查找matrix中以它为先决课程的依赖课程，并更新indegree中对应的数值，当依赖课程取消了所有依赖条件后，将其也入队列。
   > 4. 最终比较出队列的课程数量与总课程数量，若一致则说明课程合理。

   ```java
   class Solution {
       public boolean canFinish(int numCourses, int[][] prerequisites) {
       // 存放限制条件的数组
       int[][] matrix = new int[numCourses][numCourses]; // i -> j
       // 每门课程依赖其它课程的数量
       int[] indegree = new int[numCourses];
       
       for (int i=0; i<prerequisites.length; i++) {
           int ready = prerequisites[i][0];
           int pre = prerequisites[i][1];
           if (matrix[pre][ready] == 0)
               indegree[ready]++; //duplicate case
           matrix[pre][ready] = 1;
       }
       
       int count = 0;
       Queue<Integer> queue = new LinkedList();
       // 将没有依赖其它课程的课程入队列，该队列表示当前可学习的课程
       for (int i=0; i<indegree.length; i++) {
           if (indegree[i] == 0) queue.offer(i);
       }
       while (!queue.isEmpty()) {
           // 先学习没有依赖的课程A
           int course = queue.poll();
           count++;
           // 学习完A后遍历限制表，查询以A为依赖的课程，若它们除A外没有其他依赖，则将其入队列，表示这门课当前已经可以学习。
           for (int i=0; i<numCourses; i++) {
               if (matrix[course][i] != 0) {
                   if (--indegree[i] == 0)
                       queue.offer(i);
               }
           }
       }
       // 判断最终学习数与课程总数是否一致
       return count == numCourses;
   }
   }
   ```

3. 设计一个容器，实现insert、search、startWith功能。

   > TODO：better discuss

   ```java
   class Trie {
       Set<String> ss = new HashSet<>();
       /** Initialize your data structure here. */
       public Trie() {
           
       }
       
       /** Inserts a word into the trie. */
       public void insert(String word) {
            ss.add(word);
       }
       
       /** Returns if the word is in the trie. */
       public boolean search(String word) {
           return ss.contains(word);
       }
       
       /** Returns if there is any word in the trie that starts with the given prefix. */
       public boolean startsWith(String prefix) {
           for(String word : ss) {
               if(word.startsWith(prefix)) return true;
           }
           return false;
       }
   }
   
   /**
    * Your Trie object will be instantiated and called as such:
    * Trie obj = new Trie();
    * obj.insert(word);
    * boolean param_2 = obj.search(word);
    * boolean param_3 = obj.startsWith(prefix);
    */
   ```

## 2018-12-22

1. 输入LIst\<Interval> intervals，Interval表示一段间隔，包含start和end两个参数，当两个Interval间隔有重叠时，将其合并成一个Interval。输出合并后的List\<Interval> results。#56

   > 基本思路：采用插入合并的方法，每往results插入v1，均遍历一次results。遍历之前定义一个合并项cur（初始值为v1），若遍历过程中发现重合项v2，从results中移除v2，合并cur和v2并更新cur。继续往下遍历合并，将最终的合并项cur添加至results中。
   >
   > TODO：better discuss

   ```java
   /**
    * Definition for an interval.
    * public class Interval {
    *     int start;
    *     int end;
    *     Interval() { start = 0; end = 0; }
    *     Interval(int s, int e) { start = s; end = e; }
    * }
    */
   class Solution {
       List<Interval> results = new ArrayList<>();
       public List<Interval> merge(List<Interval> intervals) {
           if(intervals == null || intervals.size() == 0)
               return results;
           for(Interval i : intervals) {
               append(i);
           }
           return results;
       }
       
       private void append(Interval object) {
           if(results.size() == 0){
               results.add(object);
               return;
           }
           Interval cur = new Interval(object.start, object.end);
           Iterator<Interval> it = results.iterator();
           while(it.hasNext()) {
               Interval item = it.next();
               if(overlap(cur,item)) {
                   it.remove();
                   cur = merge(cur, item);
               }
           }
           results.add(cur);
       }
       
       private boolean overlap(Interval v1, Interval v2) {
           return !(Math.max(v1.start, v2.start) > Math.min(v1.end, v2.end));
       }
       
       private Interval merge(Interval v1, Interval v2){
           return new Interval(Math.min(v1.start, v2.start), Math.max(v1.end, v2.end));
       }
   }
   ```

2. 输入一课二叉树和任意两个节点A、B，输出这两个节点的最近共同祖先。#236

   > 基本思路：中序遍历二叉树生成列表。遍历整颗树，若列表中A、B在根节点两侧，则该根节点是A、B的最近公共祖先。
   >
   > TODO：better discuss

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       private List<Integer> inorderList = new ArrayList<Integer>();
       private TreeNode ancestor;
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           inorder(root);
           findAncestor(root, p, q);
           return ancestor;
       }
       private void inorder(TreeNode root) {
           if(root == null) return;
           inorder(root.left);
           inorderList.add(root.val);
           inorder(root.right);
       }
       private void findAncestor(TreeNode root, TreeNode p, TreeNode q) {
           if(root == null) return;
           if(ancestor != null) return;
           if(inorderList.indexOf(root.val) >= inorderList.indexOf(p.val)
             && inorderList.indexOf(root.val) <= inorderList.indexOf(q.val)
             || (inorderList.indexOf(root.val) <= inorderList.indexOf(p.val)
             && inorderList.indexOf(root.val) >= inorderList.indexOf(q.val))) {
               ancestor = root;
               return;
           }
           findAncestor(root.left, p, q);
           findAncestor(root.right, p, q);
                   
       }
   }
   ```

3. 输入一个单链表，要求删除倒数第n个节点。#19

   > 基本思路：借助一个List存储每个节点的位置索引，倒数第n个就是正数第（size-n+1）个，该数的索引是（size-n），要删除它需要使用前一个节点的索引（size-n-1）。
   >
   > TODO：better discuss

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode removeNthFromEnd(ListNode head, int n) {
           List<ListNode> list = new ArrayList<>();
           ListNode it = head;
           while(it!= null) {
               list.add(it);
               it = it.next;
           }
   		
           // 删除第一个节点时直接移动head指针即可
           if(list.size() - n < 1) {
               // delete first item
               head = head.next;
           }else{
               it = list.get(list.size() - n - 1);
               it.next = it.next.next;  
           }
          
           return head;
       }
   }
   ```

4. （Star）输入一个字符串和字典，问字符串能否被字典中的单词完美划分。#139

   > 基本思路：
   >
   > 1. 递归思想（recursion）。长度为len的字符串被完美划分（split(len)返回true）的条件是：split(i) 返回true并且substring(i, length)在字典中存在，其中i是0~len-1遍历的索引。使用该方法在LeetCode上提交会报Time Limit Exceeded错误。
   > 2. DP思想：使用DP[]数组记录0~i-1能否被完美划分的结果，减少递归的重复运算。

   ```java
   // 1.recursion
   class Solution {
       public boolean wordBreak(String s, List<String> wordDict) {
            return split(s, wordDict, s.length());
       }
       
       private boolean split(String s, List<String> dict, int len){
           if(len == 0) return true;
           for(int i = 0; i < len; i++) {
               String sub = s.substring(i, len);
               if(split(s, dict, i) && dict.contains(sub)) return true;
           }
           return false;
       }
   }
   
   // 2.DP
   class Solution {
       public boolean wordBreak(String s, List<String> wordDict) {
           boolean[] DP = new boolean[s.length() + 1];
           DP[0] = true;
           for(int i = 1; i <= s.length(); i++) {
               for(int j = 0; j < i; j++) {
                   String sub = s.substring(j, i);
                   if(DP[j] && wordDict.contains(sub)) {
                       DP[i] = true;
                       break;
                   }
               }
           }
           return DP[s.length()];
       }
   }
   ```


## 2018-12-23

1. （Star）输入一个无序链表，输出一个有序链表，要求时间复杂度为O（nlogn），空间复杂度为O（1）。#148

   > 基本思路：
   >
   > 使用合并排序的思想，将链表均分成两段，分别对每段进行合并排序（递归），将排序后的链表合并。
   >
   > 分割链表的思想很赞，值得学习。

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode sortList(ListNode head) {
           // merge sort, nice solution!
           if (head == null || head.next == null) return head;
   
           // step1: split list in two half
           ListNode fast = head, slow = head, prev = null;
           while (fast != null && fast.next != null) {
               prev = slow;
               slow = slow.next;
               fast = fast.next.next;
           }
           prev.next = null;
   
           // step2: sort two half list
           head = sortList(head);
           slow = sortList(slow);
   
           // step3: merge two sorted list
           return merge(head, slow);
       }
   
       public ListNode merge(ListNode l1, ListNode l2) {
           ListNode p = new ListNode(0);
           ListNode head = p;
   
           while (l1 != null && l2 != null) {
               if (l1.val < l2.val) {
                   p.next = l1;
                   l1 = l1.next;
               } else {
                   p.next = l2;
                   l2 = l2.next;
               }
               p = p.next;
           }
           if (l1 != null) p.next = l1;
           if (l2 != null) p.next = l2;
           // head is invalid
           return head.next;
       }
   }
   ```

2. Course Schedule II，12-20 题二的进阶题目。输入课程总数N和课程之间的依赖关系，输出一张合理的课程表，若不存在合理课表则输出空表。#210

   > 基本思路：本题和12-20题二的解法一致，将依赖关系转换成N*N的二维数组，方便查询，新建一个数组reply[]用于存储ready课程的依赖数目，优先上不依赖别人的课程，每上一门课程在reply[]中将对应课程的依赖数目减一，若对应课程不再依赖别人，将它也放入pre队列。每上一门课就将其记录到output数组中，若课表是存在的则将课表输出。

   ```java
   class Solution {
       public int[] findOrder(int numCourses, int[][] prerequisites) {
           // the same solution as 1
           // x is ready course, y is pre course
           int[][] matrix = new int[numCourses][numCourses];
           // reply number with ready course
           int[] reply = new int[numCourses];
           for(int i = 0; i < prerequisites.length; i++) {
               matrix[prerequisites[i][1]][prerequisites[i][0]] = 1;
           }
           
           for(int i = 0; i < numCourses; i++) {
               for(int j = 0; j < numCourses; j++) {
                   if(matrix[i][j] == 1) {
                       reply[j]++;
                   }
               }
           }
           
           LinkedList<Integer> queue = new LinkedList<>();
           for(int i = 0; i < numCourses; i++) {
               if(reply[i] == 0) queue.offer(i);
           }
           
           int count = 0; 
           int[] output = new int[numCourses];
           while(!queue.isEmpty()) {
               int pre = queue.poll();
               output[++count - 1] =  pre;
               for(int i = 0; i < numCourses; i++) {
                   if(matrix[pre][i] == 1) {
                       if(--reply[i] == 0) {
                           queue.offer(i);
                       }
                   }
               }
           }
           
           if(count < numCourses) return new int[]{};
           return output;
       }
   }
   ```


## 2018-12-24

1. 输入一个数组和目标数值，输出目标数值在数组中的起始索引和终止索引，若数值不存在则输出[-1,-1]，要求时间复杂度为O(logn)。

   > 基本思路：使用二分查找（递归）
   >
   > TODO：better discuss

   ```java
   class Solution {
       int count = 0;
       int[] res = new int[]{-1, -1};
       public int[] searchRange(int[] nums, int target) {
           if(nums == null || nums.length == 0) return res;
           search(nums, 0, nums.length-1, target);
           if(count == 0) return new int[]{-1, -1};
           res[1] = res[0] + count - 1;
           return res;
       }
       
       private void search(int[] nums, int l, int r, int target) {
           if(l==r) {
               if(nums[l]==target) {
                   if(res[0] == -1) res[0] = l;
                   count++;
               }
               return;
           }
           int mid = (l+r)/2;
           search(nums, l, mid, target);
           search(nums, mid+1, r, target);
       }
   }
   ```

2. （Star）输入一个滚动后的递增序列，如[6,7,8,1,2,3,4,5]，输入target，输出target的所在索引，若target不存在则输出-1。要求时间复杂度为O(logn)。

   > 基本思路：这是二分查找的变种。无论有序序列如何滚动，将数组分成两半，总有一半是递增的，判断target是否在这一半区间内，若不在则继续去另一半查找。

   ```java
   public class Solution {
   public int search(int[] A, int target) {
       if(A.length == 0) return -1;
       int lo = 0;
       int hi = A.length - 1;
       while (lo < hi) {
           int mid = (lo + hi) / 2;
           if (A[mid] == target) return mid;
           
           if (A[lo] <= A[mid]) {
               if (target >= A[lo] && target < A[mid]) {
                   hi = mid - 1;
               } else {
                   lo = mid + 1;
               }
           } else {
               if (target > A[mid] && target <= A[hi]) {
                   lo = mid + 1;
               } else {
                   hi = mid - 1;
               }
           }
       }
       return A[lo] == target ? lo : -1;
   }
   }
   ```


## 2018-12-25

1. 输入gas[]和cost[]数组，分别表示当前油站可补充油量和到下一个油站的消耗油量。请问汽车能否开一个循环，如果能请输出初始油站，若不能则输出-1。

   > 基本思路：遍历将每个加油站作为初始油站，判断能否走完一个循环。
   >
   > TODO：better discuss

   ```java
   class Solution {
       public int canCompleteCircuit(int[] gas, int[] cost) {
           int start = 0;
           for(start = 0; start < gas.length; start++) {
               int left = 0; 
               int travel = 0;
               while(travel < gas.length) {
                   left += gas[(start + travel) % gas.length];
                   left -= cost[(start + travel) % gas.length];
                   if(left < 0) break;
                   travel++;
               }
               if(travel >= gas.length) break;
           }
           return start < gas.length ? start : -1;
       }
   }
   ```


## 2018-12-27

1. 输入一个逆波兰式（RPN，后缀表达式，将运算符放在操作数之后），例如["2", "1", "+", "3", "*"]，表示((2 + 1) * 3) = 9。输出正确的解。#150

   > 基本思路：使用Stack，当遇到操作数时直接入栈，遇到运算符时将栈顶两个数出栈，并将运算结果入栈。

   ```java
   class Solution {
       public int evalRPN(String[] tokens) {
           if(tokens == null || tokens.length==0)return 0;
           Stack<String> stack = new Stack<>();
           for(String s : tokens) {
               if(s.equals("+")){
                   int x = Integer.valueOf(stack.pop());
                   int y = Integer.valueOf(stack.pop());
                   stack.push(x+y+"");
               } else if(s.equals("-")){
                   int x = Integer.valueOf(stack.pop());
                   int y = Integer.valueOf(stack.pop());
                   stack.push(y-x+"");
               }else if(s.equals("*")){
                   int x = Integer.valueOf(stack.pop());
                   int y = Integer.valueOf(stack.pop());
                   stack.push(x*y+"");
               }else if(s.equals("/")){
                   int x = Integer.valueOf(stack.pop());
                   int y = Integer.valueOf(stack.pop());
                   stack.push(y/x+"");
               }else{
                   stack.push(s);
               }
           }
           
           return Integer.valueOf(stack.pop());
       }
   }
   ```

2. （Star）在二维字符数组中，找一个字符串S，要求字符串的相邻元素在数组中也是相邻的（横向或纵向），数组中的每个元素只能使用一次，#79

   > 基本思路：使用回溯法。首先找到与S首字母相同的元素，从该元素开始向四周元素进行递归搜索，看是否能找到与S一致的路径。由于元素不能重复使用，因此需要借助一个bool数组记录该元素是否已经用过。有个较好的思路是当元素a被使用后，将a的第8个bit置反（a^256），因为char占两个字节，又因为ASC表长度为178，将第8位置反后该字符无法匹配到任何ASC字符，相当于被标记为了已读，**当前回溯结束时再将该位恢复**即可。

   ```java
   class Solution {
       char[][] mBoard;
       boolean[][] matrix;
       int width;
       int height;
       public boolean exist(char[][] board, String word) {
           mBoard = board;
           if(word.length() == 0) return true;
           if(board.length == 0) return false;
           width = board[0].length;
           height = board.length;
   
           for(int i = 0; i<height;i++){
               for(int j = 0;j<width;j++){
                   if(word.charAt(0)==board[i][j]){
                       matrix=new boolean[height][width];
                       if(search(i,j,word,0)) return true;
                   }
               }
           }
           return false;
   
       }
   
       public boolean search(int x, int y, String word, int kth) {
           if(kth >= word.length()) return true;
           if(x<0||y<0||x>height-1||y>width-1)return false;
           if(matrix[x][y])return false;
           if(mBoard[x][y]!=word.charAt(kth))return false;
           matrix[x][y]=true;
           boolean exist = search(x-1,y,word,kth+1)
           ||search(x+1,y,word,kth+1)
           ||search(x,y-1,word,kth+1)
           ||search(x,y+1,word,kth+1);
           matrix[x][y]=false;
           return exist;
       }
   }
   ```

3. 螺旋型输出一个二维数组。#54

   > Input:
   > [
   >  [ 1, 2, 3 ],
   >  [ 4, 5, 6 ],
   >  [ 7, 8, 9 ]
   > ]
   >
   > Output: [1,2,3,6,9,8,7,4,5]
   >
   >
   >
   > 基本思路：
   >
   > 使用四个变量left，right，top，bot表示四面墙，使用dir表示输出的方向，当输出撞墙时切换方向。难点在于终止条件的判断，当两面墙相遇时停止输出。
   >
   > TODO：该题的临界位置判断不够清晰，Better discuss

   ```java
   class Solution {
       enum Direction {
           LEFT, RIGHT, UP, DOWN
       }
       public List<Integer> spiralOrder(int[][] matrix) {
           List<Integer> results = new ArrayList<Integer>();
           Direction dir = Direction.RIGHT;
           if(matrix == null || matrix.length == 0) return results;
           int left = -1, right = matrix[0].length, top = 0, bot = matrix.length;
           int x=0,y=0;
           while(left<right && bot>top) {
               if(dir == Direction.RIGHT) {
                   if(y<right) {
                       results.add(matrix[x][y]);
                       y++;
                   }
                   else {
                       dir=Direction.DOWN;
                       right--;
                       y--;
                       x++;
                   }
               } else if(dir == Direction.DOWN) {
                   if(x<bot){
                       results.add(matrix[x][y]);
                       x++;
                   }
                   else {
                       dir=Direction.LEFT;
                       bot--;
                       x--;
                       y--;
                   }
               } else if(dir == Direction.LEFT) {
                   if(y>left){
                       results.add(matrix[x][y]);
                       y--;
                   }
                   else{
                       dir=Direction.UP;
                       left++;
                       y++;
                       x--;
                   }
               } else if(dir == Direction.UP) {
                   if(x>top) {
                       results.add(matrix[x][y]);
                       x--;
                   }
                   else{
                       dir=Direction.RIGHT;
                       top++;
                       x++;
                       y++;
                   }
               }
           }
           return results;
       }
   }
   ```




## 2018-12-28

1. （Star）输入一个数组coins和一个amount，挑选array中的元素使得元素和为amount，输出元素数量k，要求k的值尽可能的小。#322

   > 基本思路：首先考虑DP是否可以解题，由于amount组合未知，无法使用从下到上的动态规划算法，退而求其次使用从上到下到备忘录算法。有以下两种回溯思路：
   >
   > 1. 要求conis[0~n-1]数组的和为amount的最优解时，将第n个数剔除，遍历i，求coins[0~n-2]数组的和为（amount-i*coins[n-1]）的最优解（i的遍历限制是amount-i\*coins[n-1]>0）。使用这种思路即便每次回溯记录下最优解并且借助贪婪思想（将coins排序，优先剔除较大值），依然会报Time Limit Exceeded错误。
   > 2. 要求conis[0~n-1]数组的和为amount的最优解时，遍历coins，分别求conis[0~n-1]数组的和为amount-coins[i]的最优解。该回溯思路的临界条件是当amount为0时直接返回0。使用这种思路再配合备忘录即可快速获取正确结果。

   ```java
   // normal recursion + greedy
   class Solution {
       public int coinChange(int[] coins, int amount) {
           return recursion(coins, coins.length, amount);
       }
       
       private int recursion(int[] coins, int size, int amount) {
           if(size == 1){
               if(amount % coins[0] == 0) return amount / coins[0];
               return -1;
           }
           
           int n = 0, left = amount, min = Integer.MAX_VALUE;
           while( left > 0) {
               int number = recursion(coins, size - 1, left);
               if(number != -1){
                   min = Math.min(min, number+n);
               }
               n++;
               left = amount - n*coins[size-1];
           }
           if(left == 0) min = Math.min(min, n);
           return min == Integer.MAX_VALUE ? -1 : min;
       }
   }
   
   // skr recursion
   class Solution {
       public int coinChange(int[] coins, int amount) {
           return recursion(coins, amount, new int[amount]);
       }
       
       private int recursion(int[] coins, int amount, int[] book) {
           if(amount<0) return -1;
           if(amount==0) return 0;
           if(book[amount-1]!=0) return book[amount-1];
           
           int min = Integer.MAX_VALUE;
           for(int coin : coins) {
               int res = recursion(coins, amount-coin, book);
               if(res!=-1) min = Math.min(min, res+1);
           }
           min = min==Integer.MAX_VALUE?-1:min;
           book[amount-1]=min;
           return min;
       }
   }
   ```

2. （Star）输入一个数组，输出连续子序列相乘最大的积。#152

   > 基本思路：脑洞题！
   >
   > 1. 普通思路是用两个for循环遍历所有子序列的情况求出最大积。但是这样做会报Time Limit Exceeded错误。
   > 2. 贪婪算法的思想是求出包含当前元素的最大积和最小积，以最大积举例，求MaxPre\*A[i]，MinPre\*A[i]，A[i]三者的最大值。将该最大值与全局最大值进行比较，绝妙！！！

   ```java
   // normal solution
   class Solution {
       public int maxProduct(int[] nums) {
           if(nums == null || nums.length == 0) return 0;
           int max = Integer.MIN_VALUE;
           for(int i = 0; i < nums.length; i++) {
              int subMax = nums[i];
              int DP[] = new int[nums.length];
              DP[i]=nums[i];
              for(int j = i+1; j < nums.length; j++){
                  DP[j] = DP[j-1] * nums[j];
                  subMax = Math.max(subMax, DP[j]);
              }
              max = Math.max(max, subMax);
           }
           return max;
       }
   }
   
   // skr skr solution!
   class Solution {
       public int maxProduct(int[] A) {
           if (A.length == 0) {
               return 0;
           }
       
           int maxPre = A[0], minPre=A[0];
           int max = A[0];
           int maxCur, minCur;
           
           for(int i = 1; i < A.length; i++) {
               maxCur = Math.max(Math.max(maxPre*A[i], minPre*A[i]), A[i]);
               minCur = Math.min(Math.min(maxPre*A[i], minPre*A[i]), A[i]);
               max = Math.max(maxCur, max);
               maxPre = maxCur;
               minPre = minCur;
           }
           return max;
      
       }
   
   }
   ```
