# 春招冲刺

## 2018-12-03

1. 在一个长度为n的数组里所有数字都在0～n-1范围中，请输出重复数字。

   ```java
   // 解法一：(TODO) 先排序，后遍历查找重复数字，时间复杂度O(nlogn)
   // 解法二：(TODO) 开辟一个哈希数组，时间复杂度O(n)，空间复杂度O(n)
   // 解法三：遍历数组，将下标为i的数字与下标为N[i]的数字比较，找到重复数字。时间复杂度O(n)，空间复杂度O(1)
   int duplicate(const int[] N) {
       if(N == null || N.length == 0) {
           return -1;
       }
       
       for(int i = 0; i < N.length; i++) {
           while(N[i] != i) {
              if(N[i] == N[N[i]]) {
               	return N[i];
           	} 
               int tmp = N[i];
               N[i] = N[tmp];
               N[tmp] = tmp;
           }
       }
   }
   ```

2. 输入一个二叉树，输出二叉树的中序遍历数组。#94

   > 中序遍历：右子节点->根节点->左子节点
   >
   > 先序遍历：根节点->左子节点->右子节点
   >
   > 后序遍历：左子节点->右子节点->根节点



   ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          List<Integer> output = new ArrayList<Integer>();
          public List<Integer> inorderTraversal(TreeNode root) {
              if(root == null) {
                  return output;
              }
              inorderTraversal(root.left);
              output.add(root.val);
              inorderTraversal(root.right);
              return output;
          }
      }
   ```

3. 输入size大于1的input数组，输出output数组，要求output中下标为i的元素是input所有元素（除下标为i的元素）之积，要求时间复杂度为O(n)。#238

   ```java
   class Solution {
       public int[] productExceptSelf(int[] nums) {
           if(nums == null || nums.length <= 1)
           {
               return null;
           }
           int size = nums.length;
           int[] results = new int[size];
           int multiple = 1;
           for(int i = size - 1; i >= 0; i--) {
               results[i] = multiple;
               multiple *= nums[i];
           }
           
           multiple = 1;
           for(int i = 0; i < size - 1; i++) {
               multiple *= nums[i];
               results[i + 1] *= multiple; 
           }
           
           return results;
       }
   }
   ```

4. 输入一个数组，要求输出该数组中出现最频繁的k个值的列表。要求时间复杂度不大于O(nlogn)。#347

   ```java
   class Solution {
       
       public List<Integer> topKFrequent(int[] nums, int k) {
           HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
           List<Integer>[] bucket = new List[nums.length + 1];
           
           for(int key : nums) {
               if(map.containsKey(key)) {
                   map.put(key, map.get(key) + 1);
               } else {
                   map.put(key, 1);
               }
           }
           
           Set<Integer> set = map.keySet();
           for(int key : set) {
               int value = map.get(key);
               if(bucket[value] == null) {
                   bucket[value] = new ArrayList<Integer>();
               }
               bucket[value].add(key);
           }
           
           List<Integer> result = new ArrayList<Integer>();
           for(int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {
               if(bucket[i] != null) {
                   result.addAll(bucket[i]);
               }
           }
           
           return result;
       }
   }
   ```

5. 将一颗二叉树平铺成只有右子节点的二叉树，从根节点到叶子结点的数字按照先序遍历的顺序排列。#114

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public void flatten(TreeNode root) {
           if(root == null)
               return;
               
           flatten(root.left);
           flatten(root.right);
           final TreeNode right = root.right;
           if(root.left != null) {
               root.right = root.left;
               root.left = null;
               final TreeNode leaf = findRightLeafNode(root.right);
               if(leaf != null)
                   leaf.right = right;
           }
       }
       
       public TreeNode findRightLeafNode(TreeNode root){
           if(root == null)
               return null;
           if(root.right == null)
               return root;
           return findRightLeafNode(root.right);
       }
   }
   ```

6. 找K大。#215

   > 考察排序算法：TODO



   ```java
   // simplest approach, O(nlogn) running time + O(1) memory
   class Solution {
       public int findKthLargest(int[] nums, int k) {
           final int N = nums.length;
           Arrays.sort(nums);
           return nums[N - k];
       }
   }
   ```


## 2018-12-04

1. （Star）输入一个数组，输出该数组的所有序列List<List\<Integer\>>。#46

   > 基本思路：
   >
   > 1. n个数的数组有n\*(n-1)\*...\*2\*1种组合。
   > 2. 当a添加至包含n-1个数的数组时，将a与数组中的每个数替换，都会有(n-1)\*(n-1)\*…1种组合，最终形成第一点所说的组合数目。
   >
   > Tips：List的addAll和clone都是浅拷贝，每个元素都指向同一块内存地址。



   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> results = new ArrayList<List<Integer>>();
           
           permuteRecursion(results, nums, 0, nums.length - 1);
           
           return results;
       }
       
       public void permuteRecursion(List<List<Integer>> results, int[] nums, int start, int end) {
           if(start == end) {
               List<Integer> result = new ArrayList<Integer>();
               for (int num : nums) {
                   result.add(num);
               }
               results.add(result);
           } else {
               for(int i = start; i <= end; i++) {
                   nums = swap(nums, start, i);
                   permuteRecursion(results, nums, start + 1, end);
                   nums = swap(nums, start, i);
               }
           }
       }
       
       public int[] swap(int[] nums, int first, int second) {
           int c = nums[first];
           nums[first] = nums[second];
           nums[second] = c;
           
           return nums;
       }
   }
   ```

2. 输入n，输出所有可能的括号排序List\<String\>，要求左右括号一一对应。#22

   > Tips：String、StringBuffer、StringBuilder的区别：（TODO）
   >
   > 修改String的值本质上是给它分配了一块新的内存地址；StringBuffer的append方法则是在原来的内存地址上修改值。
   >
   > 基本思路：
   >
   > 1. 剩余左括号的数量小于等于剩余右括号的数量。
   > 2. 使用递归的思路，当剩余左括号为0时，append所有剩余右括号；当剩余左括号等于右括号时，append左括号并递归；其余情况分别append左括号和右括号并递归（append右括号时需要往List中添加新的字符串）。



   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<StringBuffer> tmp = new ArrayList<StringBuffer>();
           StringBuffer sb = new StringBuffer("");
           tmp.add(sb);
           recursion(tmp, sb, n, n);
   
           List<String> result = new ArrayList<String>();
           for(StringBuffer item : tmp) {
               result.add(item.toString());
           }
           return result;
       }
   
       public void recursion(List<StringBuffer> list, StringBuffer s, int left, int right) {
           if (left == 0) {
               while(right > 0) {
                   s.append(")");
                   right--;
               }
           }
           else if(left == right) {
               s.append("(");
               recursion(list, s, left - 1, right);
           } else {
               StringBuffer tmp = new StringBuffer(s.toString());
               s.append("(");
               recursion(list, s, left - 1, right);
               list.add(tmp.append(")"));
               recursion(list, tmp, left, right - 1);
           }
       }
   }
   ```


## 2018-12-05

1. 输入一个无重复元素的数组（distinct integers），输出所有的子集List<List\<Integer\>>，要求子集不能有重复。#78

   > 基本思路：找规律，假设已经得到nums[0～n-1]的子集Subset1，深拷贝一份子集Subset2，再将nums[n]加入Subset2的每个元素中即可。



   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> results = new ArrayList<>();
           results.add(new ArrayList<Integer>());
           if(nums == null || nums.length == 0)
               return results;
           int end = 0;
           while(end < nums.length) {
               int originSize = results.size();
               results.addAll(deepClone(results));
               for(int i = originSize; i < results.size(); i++) {
                   results.get(i).add(nums[end]);
               };
               end++;
           }
           return results;
       }
       
       public List<List<Integer>> deepClone(List<List<Integer>> reses) {
           List<List<Integer>> results = new ArrayList<>();
           for(List<Integer> res : reses) {
               List<Integer> result = new ArrayList<>();
               for(Integer i : res) {
                   result.add(i);
               }
               results.add(result);
           }
           return results;
       }
   }
   ```

2. 输入BST的根节点和k，返回BST中第k小的元素。#230

   > Tips：
   >
   > 1. BST（二叉搜索树）的概念：左子节点<根节点<右子节点。
   > 2. B树、B+树、B-树、B*树的概念。（TODO）
   >
   > 基本思路：
   >
   > BST中，中序遍历BST，第k个节点就是Kth smallest element。



   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public int kthSmallest(TreeNode root, int k) {
           List<Integer> result = new ArrayList<Integer>();
           recursion(root, result, k);
           return result.get(k - 1);
       }
       
       public void recursion(TreeNode root, List<Integer> list, int k) {
           if(root == null || list.size() >= k)
               return;
           recursion(root.left, list, k);
           list.add(root.val);
           recursion(root.right, list, k);
       }
   }
   ```
